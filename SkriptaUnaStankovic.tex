% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{listings}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{minted}
\usepackage{xcolor}


\usepackage[english,serbian]{babel}
%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

%\newtheorem{primer}{Пример}[section] %ćirilični primer
\newtheorem{primer}{Primer}[section]

\begin{document}

\title{Uvod u programiranje\\ \small{Skipta za kurs\\Uvod u programiranje kroz JavaScript\\}}

\author{Una Stanković\\ una.stankovic@code.edu.rs}
\date{10.~septembar 2018.}
\maketitle
\newpage

U ovom tekstu predstavljene su teorijske osnove potrebne za savladavanje kursa $"$ Uvod u programiranje kroz JavaScript$"$. Najpre su navedene, ukratko, teorijske osnove računarstva i uvod kroz HTML i CSS, a kasnije se ulazi u rad sa JavaScript-om.  Ova skripta je obavezan materijal pri kursu i sa prezentacijama i kodovima formira celinu. Ova skripta sama po sebi nije dovoljna, samostalan rad i istraživanje je neizostavni deo procesa učenja. U slučaju da primetite greške pri čitanju rada ili imate bilo kakve nedoumice, predloge i sugestije javite se mejlom na adresu navedenu na prvoj strani. Materijali su kreirani prvenstveno na osnovu materijala korišćenih u nastavi na Matematičkom fakultetu, iz predmeta Uvod u Veb i Internet tehnologije, Programiranje za Veb, Mrežno računarstvo i Programiranje 1.  
\newpage

\tableofcontents

\newpage

\section{Uvod u računarstvo}
\label{sec:uvod}
Računarstvo i informatika predstavljaju jednu od najvažnijih oblasti današnjice koje su u konstantnom razvoju. Danas, ne možemo zamisliti život bez računara, pametnih telefona ili mnogobrojnih uređaja koji se pokreću uz pomoć računara. Razvitak računarstva i tehnologije u poslednjih 70 godina je eksponencijalan, tako da, danas, imamo razvoj prenosnih računara, tableta, pametnih telefona i uređaja, kola, kućnih aparata i ostalih koji se pokreću korišćenjem računarskih sistema. Kako definisati računarski sistem? Postoji više različitih računarskih sistema, od kojih svaki ima svoju posebnu definiciju, ali naš fokus je na digitalnim računarskim sistemima. Oni podrazumevaju mašinu koja može da se programira kako bi izvršavala različite zadatke svođenjem na elementarne operacije nad brojevima. Brojevi se u računaru zapisuju uz pomoć nula i jedinica, odnosno, binarnim zapisom, kao nizovi bitova. \\\\
Kada se razmišlja o tome šta sve računarstvo obuhvata, lako se uviđa da računarstvo nije samo računar, već da ono predstavlja mnogo širu oblast koja se bavi izučavanjem teorije i prakse procesa računanja i primene računara u različitim naučnim oblastima, tehnici i svakodnevnom životu. Računar sam po sebi nije cilj, već sredstvo za postizanje različitih ciljeva u zavisnosti od njihove primene. Za današnje računare često ćemo čuti da su $"$programabilni$"$, ali šta to zapravo govori? Programabilnost računara se ogleda u činjenici da je moguće računaru dati neki skup instrukcija koje će on izvršavati sa ciljem ispunjavanja određenih zadataka, koje mu čovek, odnosno, programer zadaje. Računari kakve danas poznajemo nastali su polovinom XX veka, ali želja za automatizacijom određenih postupaka seže daleko dalje u prošlost. Naime, posmatrajući istorijski, ljudi su vekovima stvarali razne naprave koje su mogle da rešavaju neke numeričke zadatke. 

\subsection{Istorijat računarstva}
Da bismo u potpunosti razumeli računarstvo moramo imati uvid u njegove početke i razvoj. Istorijski gledano, koreni ljudske želje da olakšaju sebi svakodnevni život sežu davno u prošlost. Kao pravi primer takvih težnji možemo uzeti jedne od prvih računaljki abakus. U $18.$ veku nastale su prve mehaničke sprave koje su mogle da vrše automatsko izvođenje aritmetičkih operacija i pomažu u rešavanju matematičkih zadataka. Blez Paksal\footnote{Blaise Pascal (1623–1662), francuski filozof, matematičar i fizičar. U njegovu čast jedan
programski jezik nosi ime PASCAL.} je $1642.$ godine konstruisao mehaničke sprave koje su služile za sabiranje i oduzimanje celih brojeva, zvane Paskaline. Trideset godina nakon njega, Godfrid Lajbnic\footnote{Gottfried Wilhelm Leibniz (1646–1716), nemački filozof i matematičar} konstruisao je mašinu, zasnovanu na dekadnom sistemu, koja je mogla da vrši sve četiri osnovne operacije. Lajbnic je bio prvi koji je predlagao koriscenje binarnog sistema.\\\\ 
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/abakus.jpg}
\end{center}
\caption{Abakus}
\label{fig:abakus}
\end{figure}
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/pasc.jpg}
\end{center}
\caption{Paskalina}
\label{fig:pasc}
\end{figure}
\subparagraph{Mehaničke mašine} Žozef Mari Žakard\footnote{Joseph Marie Jacquard (1752–1834), francuski trgovac.} je $1801.$ godine napravio prvu programabilnu mašinu — mehanički tkački razboj. On je pomoću bušenih kartica
kreirao kompleksne šare na tkanini. Svaka rupa na kartici određivala je jedan pokret mašine, a svaki red na kartici odgovarao je jednom redu šare.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/loom.jpg}
\end{center}
\caption{Žakardov razboj}
\label{fig:jacques}
\end{figure}
U prvoj polovini $19.$ veka, Čarls Bebidž\footnote{Charles Babbage (1791–1871), engleski matematičar, filozof i pronalazač.} je dizajnirao prve programabilne računske mašine.  Godine 1822. započeo je rad na diferencijskoj mašini, za računanje vrednosti polinomijalnih funkcija. Ime je dobila zbog toga što je koristila tzv. metod konačnih razlika da bi bila eliminisana potreba za množenjem i deljenjem. Mašina je trebalo da ima oko 25000 delova i da se pokreće ručno, ali nije nikada završena.
Ubrzo nakon toga, Bebidž je započeo rad na novoj mašini nazvanoj analitička mašina. Osnovna razlika u
odnosu na sve prethodne mašine specifičnih namena, bila je u tome što je analitička mašina zamišljena kao računska mašina opšte namene. $"$Programiranje$"$  na ovoj mašini vršilo bi se programima zapisanim na bušenim karticama (sličnim Žakardovim), a program bi kontrolisao mehanički račuunar koji bi omogućavao sekvencijalno izvršavanje naredbi, grananje i skokove. Osnovni delovi ovog računara trebalo je da budu mlin (engl. mill) i skladište (engl. store), koji po svojoj funkcionalnosti sasvim odgovaraju procesoru i
memoriji današnjih računara. Ada Bajron\footnote{Augusta Ada King (rođ. Byron), Countess of Lovelace, (1815–1852), engleska matematičarka.
U njenu čast nazvan je programski jezik ADA.} zajedno sa Bebidžem napisala je
prve programe za analitičku mašinu i, da je mašina uspešno konstruisana, njeni
programi bi mogli da računaju određene složene nizove brojeva (takozvane Bernulijeve
brojeve). Upravo je to razlog zašto se ona smatra prvim programerom u istoriji. Ona je bila i prva koja je uvidela da se računarske mašine mogu upotrebiti i u nematematičke namene, čime je naslutila današnjicu.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/bebidz.jpg}
\end{center}
\caption{Bebidžova diferencijska mašina}
\label{fig:beb}
\end{figure}

\subparagraph{Elektromehaničke mašine}
Ove mašine koristile su se od sredine $19.$ veka do Drugog svetskog rata.
Jednu od prvih mašina za čitanje bušenih kartica konstruisana je od strane Hermana Holerita. Njena glavna svrha bila je obrada rezultata popisa stanovništva u Sjedinjenim američkim državama 1890. godine. 
Koristeći bušene kartice uspešno izvršen je popis za godinu dana, naspram deset godina, koliko je bilo potrebno ranije. Od Holeritove male kompanije nastao je IBM.\footnote{Herman Hollerith (1860–1929), američki pronalazač.}

\subparagraph{Elektronski računari} Elektronski računari koriste se od kraja 1930-ih do
danas. 
 
\subsection{Fon Nojmanova arhitektura}
\label{sec:fN}
Na osnovu istorijata može se uočiti da svi navedeni računari imaju nedostatak jedne važne karakteristike računara danas, a to je programabilnost. Mašine korišćene nekada nisu bile programabilne već su funkcionisale po unapred definisanom programu određenom samom konstrukcijom mašine. Iako ovakav pristup nije sasvim izumro (danas se može videti na primeru digitrona), uglavnom nije poželjan. Prava promena u pristupu, koja je dovela do stvaranja programabilnih računara, nastala je ranih 1940-ih godina sa pojavom računara koji bi programe koje izvršavaju čuvali u memoriji zajedno sa podacima. Takve računare nazivamo računarima sa skladištenim podacima (engl. stored program computers). Jedna od najvažnijih karakteristika ovih računara je da kod njih postoji jasna podela na hardver i softver. Za rodonačelnika ovakve arhitekture smatra se Džon fon Nojman. On je 1945. godine opisao arhitekturu čija je glavna karakteristika da se programi mogu učitavati isto kao i podaci koji se obrađuju. Primeri prvih ovakvih računara su EDVAC, Mark 1 i EDSAC.\\\\
Osnovni elementi fon Nojmanove arhitekture su:
\begin{enumerate}
\item procesor - koji čine aritmetičko-logička jedinica, kontrolna jedinica i registri, i 
\item glavna memorija 
\end{enumerate}
koji su međusobno povezani, dok se ostale komponente računara smatraju pomoćnim. Prikaz fon Nojmanove arhitekture je na slici \ref{fig:fonN}.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/fonN.png}
\end{center}
\caption{Šematski prikaz fon Nojmanove arhitekture}
\label{fig:fonN}
\end{figure}
Pod pomoćne komponente ubrajamo ulazno-izlazne jediice, spoljašnje memorije itd., koje da bi funkcionisale moraju biti povezane na centralni deo računara (procesor i glavnu memoriju).
Osnovna uloga procesora je obrada podataka, dok je osnovna uloga memorije skladištenje podataka koji se obrađuju, kao i programa. Postoji jedinstven način na koji zapisujemo i podatke i programe, a to je uz pomoć nula i jedinica, odnosno, binarnim zapisom. Tokom rada računara podaci i programi se prenose između procesora i glavne memorije.
\subparagraph{Procesor} Prva centralna komponenta fon Nojmanove arhitekture. Procesor, koji je odgovoran za rad računara, sastoji se od \textit{kontrolne jedinice} - koja upravlja radom procesora i \textit{aritmetičko-logičke jedinice} - koja je zadužena za izvođenje aritmetičkih operacija (sabiranje, oduzimanje, množenje, poređenje, itd. ) i logičkih operacija (konjunkcija, negacija, itd. ) nad brojevima. Osim dva navedena dela procesor sadrži i određeni broj registara, obično fiksirane širine (8, 16, 32 ili 64 bita), koji privremeno mogu da čuvaju podatke. Danas procesori neretko poseduju više jezgara (engl. core) koja istovremeno izvršavaju instrukcije čime se obezbeđuje paralelno izvršavanje.
\subparagraph{Memorija} Druga centralna komponenta fon Nojmanove arhitekture
je glavna memorija. Memorija predstavlja linearno uređeni niz registara, pri čemu svaki ima svoju adresu. Kao posledica osobine ove memorije da se sadržaju može pristupati u slučajnom redosledu, čest naziv je i memorija sa slobodnim pristupom (engl. RAM - random access memory). Razlikujemo nekoliko parametara koji odlikuju memoriju, to su:
\begin{itemize}
\item kapacitet - GB,
\item vreme pristupa - vreme potrebno da se memorija pripremi za čitanje ili upis i 
\item protok - izražava količinu podataka koji se prenose po jedinici merenja (danas obično mereno u GBps).
\end{itemize}
Na slici \ref{fig:memh} može se videti memorijska hijerarhija.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/mem_hijer.jpg}
\end{center}
\caption{Šematski prikaz memorijske hijerarhije}
\label{fig:memh}
\end{figure}

\subsection{Hardver}
Bez obzira na činjenicu da osnovu savremenih računarskih sistema i dalje čini fon Nojmanova arhitektura, za rad računara u današnjem smislu reči potreban je i čitav niz hardverskih komponenti koje nam dodatno olakšavaju. Opis komponenti koje čine jedan računar danas ne sastoji se od kućišta, monitora, tastature i miša, već nam je potreban apstraktniji, sveobuhvatniji opis. Upravo, kako bi se jasnije i preciznije opisao računar kaže se da ga čine:
\begin{itemize}
\item procesor tj. centralna procesorska jedinica (engl. Central Processing Unit,
CPU), koja obrađuje podatke,
\item glavna memorija (engl. main memory), u kojoj se istovremeno čuvaju i
podaci koji se obrađuju i trenutno pokrenuti programi, i 
\item različiti periferijski uređaji ili ulazno-izlazne jedinice (engl. peripherals,
input-output devices, IO devices), u koje se ubrajaju miševi, tastature, ekrani,
štampači, diskovi, a koji služe za interakciju između korisnika i sistema i trajno skladištenje podataka i programa.
\end{itemize} 
Da bi se izvršilo povezivanje svih navedenih komponenti koristimo magistralu.
Za funkcionisanje modernih računara neophodni su i hardver i softver. 
Hardver (tehnički sistem računara) čine opipljive, fizičke komponente računara: procesor, memorija, matična ploča, itd. 

\subsection{Softver}
Softver računara čine programi i prateći podaci koji određuju izračunavanja koja vrši računar.
Prvi računari su se odlikovali jezicima specifičnim za konkretni računar - mašinski zavisnim jezicima. Već od 1950-ih, sa pojavom prvih jezika višeg nivoa, programiranje postaje dosta lakše. Danas, programi se najčešće pišu u višim programskim jezicima, a potom se prevode na mašinski jezik, onaj koji je razumljiv računaru. Programom opisujemo računaru koje operacije treba da izvrši sa ciljem ispunjavanja nekog zadatka. U nastavku biće navedeno nekoliko primera koji ilustruju izvršavanje programa napisanih na višim programskim jezicima. 
\begin{primer}
Želimo da izračunamo vrednost izraza $2*x + 3$ za neko $x$. Podatke u računarstvu, kao i u matematici, možemo predstaviti pomoću promenljivih. Međutim, za razliku od matematike, promenljive u računarstvu mogu menjati svoju vrednost. Svakoj promenljivoj je u memoriji računara pridruženo jedno fiksirano mesto i ona može tokom izvršavanja programa da menja vrednost. Recimo da je $x$ ulazni parametar našeg programa, a $y$ izlazna vrednost, tada izračunavanje opisujemo sa
\begin{verbatim}
y := 2*x + 3
\end{verbatim}
gde $*$ označava množenje, $+$ sabiranje, a $:=$ naredbu dodele, odnosno promenljivoj sa leve strane izraza dodeljujemo vrednost izraza sa desne strane.
\end{primer}
\begin{primer}
Kao naredni primer uzmimo poređenje dva broja, odnosno, kao izlaz treba da dobijemo veći od dva broja.
Ovakav izraz možemo zapisati kao:
\begin{verbatim}
ako je x >= y onda
    m := x
inače
    m := y
\end{verbatim}
\end{primer}
\begin{primer}
Kao još jedan primer uzmimo stepenovanje:
\begin{verbatim}
s := 1, i := 0
dok je i < n radi sledeće:
    s := s·x, 
    i := i + 1
\end{verbatim}
\end{primer}
Savremeni softver klasifikujemo u 2 kategorije:
\begin{itemize}
\item Sistemski i
\item Aplikativni.
\end{itemize}
\textbf{\em Aplikativni softver} je onaj koji krajnji korisnici računara direktno koriste u svojim svakodnevnim aktivnostima. Tu spadaju, na primer, pregledači Veba, e-mail klijenti, kancelarijski softver (programi za kucanje teksta, izradu prezentacija,...), video igre, softver za prikaz slika, itd.\\
\textbf{\em Sistemski softver} ima ulogu da kontroliše hardver i pruža usluge aplikativnom softveru. Najznačajniji skup sistemskog softvera je operativni sistem (OS), ali u sistemski softver ubrajamo i različite uslužne programe: editore teksta, alate za programiranje (prevodioci, dibageri, profajleri, integrisana okruženja) i slično. Uloga operativnog sistema je da programeru pruži skup funkcija koje programer može da koristi kako bi ispunio određeni cilj, sakrivajući konkretne hardverske detalje - ovaj skup funkcija naziva se programski interfejs za pisanje aplikacija (engl. API - Application Programming Interface).

\subsection{Oblasti savremenog računarstva}
Savremeno računarstvo sastoji se iz više podoblasti između kojih nema jasnih granica. Prema klasifikaciji američke asocijacije ACM - Association for Computing Machinery, razlikujemo naredne podoblasti~\cite{Janicic}:
\begin{itemize}
\item Algoritmika (procesi izračunavanja i njihova složenost)
\item Strukture podataka (reprezentovanje i obrada podataka)
\item Programski jezici (dizajn i analiza svojstava formalnih jezika za opisivanje
algoritama)
\item Programiranje (proces zapisivanja algoritama u nekom programskom jeziku)
\item Softversko inženjerstvo (proces dizajniranja, razvoja i testiranja programa)
\item Prevođenje programskih jezika (efikasno prevođenje viših programskih jezika,
obično na mašinski jezik)
\item Operativni sistemi (sistemi za upravljanje računarom i programima)
\item Mrežno računarstvo (algoritmi i protokoli za komunikaciju između računara)
\item Primene (dizajn i razvoj softvera za svakodnevnu upotrebu)
\item Istraživanje podataka (pronalaženje relevantnih informacija u velikim skupovima
podataka)
\item Veštačka inteligencija (rešavanje problema u kojima se javlja kombinatorna
eksplozija)
\item Robotika (algoritmi za kontrolu ponašanja robota)
\item Računarska grafika (analiza i sinteza slika i animacija)
\item Kriptografija (algoritmi za zaštitu privatnosti podataka)
\item Teorijsko računarstvo (teorijske osnove izračunavanja, računarska matematika,
verifikacija softvera, itd).
\end{itemize}

\subsection{Osnovni pojmovi i konstrukti}
Programiranje predstavlja proces zapisivanja algoritama u nekom programskom jeziku.
Algoritam predstavlja precizan opis postupka za rešavanje nekog problema u konačnom broju koraka. Algoritmi se odlikuju svojom složenošću. Ta složenost može biti vremenska ili memorijska. Vremenska složenost se odnosi na vreme potrebno za izvršavanje nekog algoritma. Memorijska složenost označava koliko memorijskih resursa je potrebno za izvršavanje algoritma. Cilj analize algoritama je predviđanje njegovog ponašanja i brzine izvršavanja bez realizacije na nekom konkretnom računaru. Ta procena treba da se odnosi na svaki računar. Nemoguće bi bilo na svakom računaru ispitati izvršavanje nekog algoritma. Zbog toga je analiza algoritama približna tehnika.~\cite{Zivkovic} Postoji uniformna tehnika za grafički prikaz algoritama, međutim, mi nećemo ulaziti u detalje, već će biti dato nekoliko ilustrativnih primera kako bi se dobila glavna ideja.
\begin{primer}
Kao najjednostavniji primer algoritma uzmimo primer sa lampom. U početnom koraku lampa je ugašena, a mi želimo da je upalimo ili, ako ne radi, da je odnesemo na popravku. Najpre, proveravamo da li je lampa uključena u struju. Romb je znak kojim označavamo uslov. Ako lampa nije uključena u struju treba je uključiti. U suprotnom, ako je lampa uključena u struju, ali ne svetli, proveravamo da li je sijalica pregorela. Ako jeste, menjamo sijalicu. Ako nije, lampa je pokvarena i moramo je popraviti. Na slici \ref{fig:alg0} vidimo kako bismo grafički prikazali opisani postupak.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/lamp.png}
\end{center}
\caption{Primer najjednostavnijeg algoritma.}
\label{fig:alg0}
\end{figure}
\end{primer}

\begin{primer}
Kao primer, više prikladan računarskoj terminologiji, uzmimo sabiranje $2$ broja, $M$ i $N$. Na slici \ref{fig:alg1} vidimo kako bismo grafički prikazali postupak sabiranja brojeva.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/sum-num-alg.png}
\end{center}
\caption{Prikaz algoritma za sabiranje dva broja.}
\label{fig:alg1}
\end{figure}
\end{primer}

U sekciji \ref{sec:fN} koja govori o fon Nojmanovoj arhitekturi, videli smo da se podaci (i programi) smeštaju u memoriju računara, najčešće u vidu niza bitova. Međutim, kako se programer ne bi zamarao detaljima i kako bi mogao da radi na dosta apstraktnijem nivou, programski jezici obezbeđuju koncept promenljivih. Promenljive daju mogućnost programeru da podacima dodeli imena i da im na osnovu tih imena i pristupa. Svaka promenljiva u programu ima dodeljen određeni niz bajtova. \\\\
Promenenljive se odlikuju svojim tipovima i životnim vekom. Životni vek je koncept koji nam govori u kom delu faze izvršavanja programa je promenljivoj dodeljen memorijski prostor, odnosno, kada je možemo koristiti. Životni vek promenljive omogućava da na različitim mestima u programu koristimo različite promenljive istog imena i pravilo dosega identifikatora (engl. scope) određuje deo programa u kome se uvedeno ime može koristiti. Druga odlika promenljivih su tipovi. Organizovanje podataka u tipove pomaže programeru da ne mora da razmišlja o podacima na nivou njihove binarne reprezentacije, već daleko apstraktnije. Neki od najčešćih tipova su:
\begin{itemize}
\item celi brojevi (... -3, -2, -1, 0, 1, 2, 3,...),
\item brojevi u pokretnom zarezu ( 1.0, 3.14, 9.81,...),
\item karakteri (a, b, P, ,, !, ...),
\item niske ("zdravo", "svima",...)
\end{itemize} 
Osim ovih postoje i složeniji tipovi koji mogu objediniti više istih ili različitih tipova, pa tako imamo nizove, strukture, liste, i dr.
Svaki tip podataka se karakteriše vrstom podataka koje opisuje, skupom operacija koje se nad njime vrše i načinom reprezentacije i detaljima implementacije tog tipa.

Osnovni gradivni elementi imperativnih programskih jezika su naredbe.
Naredba dodele je osnovna naredba i njom se vrednost neke promenljive postavlja na vrednost nekog izraza definisanog nad konstantama i promenljivim. Šta to, u praksi, znači? To znači da kada kažemo $x = 3*y$ zapravo promenljivoj x dodeljujemo vrednost $3*y$. Naredbe se u programu nižu jedna za drugom, osim u slučaju korišćenja naredbi za kontrolu toka izvršavanja programa. Ove naredbe u zavisnosti od tekućih
vrednosti promenljivih neke naredbe mogu da ne izvršavaju, izvršavaju ih više puta(petlje) i slično. Najčešće korišćene kontrolne strukture su granajuće naredbe (if-then-else), petlje (for, while, do-while, repeat-until) i naredbe skoka (goto). Naredba if-then-else ima sledeći opšti oblik:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if izraz1 
   naredba1
else 
   naredba2
\end{lstlisting}
Treba obratiti pažnju da je else grana neobavezna, odnosno, može, ali ne mora, da postoji. 
\begin{primer}
Naredni primer štampa veći od dva broja.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if a > b
   print(a)
else
   print(b)
\end{lstlisting}
\end{primer}

\begin{primer}
Naredni primer u promenljivu $a$ smešta tekst $"$Hello world!$"$ ako je vrednost promenljive b veća od 0.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if b > 0
   a = "Hello world!"
\end{lstlisting}
\end{primer}

Jedan od najbitnijih koncepata programiranja je pojam {\em petlje}. Petlje predstavljaju konstrukcije koje nam omogućuju da izvršavamo jednu ili više akcija više puta. Sastoje se iz uslova i tela petlje. Uslov nam definiše u kom slučaju ćemo napustiti petlju (na primer, ako broj iteracija\footnote{Iteracija petlje predstavlja jedno izvršavanje koda koji se nalazi u telu petlje.} petlje predje 100, ili ako je neka promenljiva n veca od 1000, itd.). Telo petlje sadrži akcije koje želimo da ponavljamo.Na slici \ref{fig:loops} može se videti opšti oblik petlji.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/Loops.png}
\end{center}
\caption{Petlja.}
\label{fig:loops}
\end{figure}

\begin{primer}
Za naredni primer, uzećemo sabiranje prvih 50 brojeva. Naime, naporno bi bilo da pišemo $1+2+3+...+50$, a da ne pomišljamo na brojeve poput $1000$, $100 000$ ili $1 000 000$. To bi bilo gotovo neizvodivo. Zbog toga, želimo da na apstraktniji način opišemo proceduru koja će umesto nas izvršiti sabiranje prvih 50 brojeva. Da bismo to uspeli moramo iskoristiti petlju. Na slici \ref{fig:alg2} vidimo kako bismo grafički prikazali postupak.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/algorithm-flow.png}
\end{center}
\caption{Prikaz algoritma za sabiranje prvih 50 brojeva.}
\label{fig:alg2}
\end{figure}
\end{primer}

Petlje su neophodne za uspešno programiranje. 
 Postoji nekoliko različitih vrsta petlji,  čija upotreba zavisi od onoga što njom želimo da postignemo, pa tako imamo:
\begin{itemize}
\item $"for"$ petlju i
\item $"while"$ petlju 
\end{itemize}
koje predstavljaju osnovne konstrukte u skoro svim programskim jezicima. Osim for i while petlje postoje i druge, ali o njima nece biti reči.\\\\
For petlja je najčešće oblika:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
for(izraz1, izraz2, izraz3)
    naredba
\end{lstlisting}
$Izraz1$ i $izraz3$ obično predstavljaju naredbe dodele ili inkrementiranje, gde se $izraz1$ obično naziva inicijalizacija, a $izraz3$ je korak. Izraz u sredini, $izraz2$, predstavlja relacijski izraz i služi kao uslov izlaska iz petlje. $Naredba$ predstavlja liniju ili blok koda koji želimo da se izvršava.
Kao posledica navedenog, $for$ petlju možemo posmatrati kao:
\begin{verbatim}
for(inicijalizacija, uslov izlaska, korak)
    kod koji želimo da se izvrši
\end{verbatim}
\begin{primer}
Naredni primer predstavlja jedan od uobičajenih oblika u kojima se $for$ petlja pojavljuje:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
for(i = 0; i < n; i++)
    print(i)
\end{lstlisting}
Ovaj primer za svaki korak petlje ispisuje broj koraka. 
\end{primer}


\subsection{Klasifikacija programskih jezika}

Brojnost programskih jezika raste iz godine u godinu. Stalno se pojavljuju novi i brži jezici, unapređuju se stari i nemoguće je ispratiti sve promene. Da bismo odmah razumeli okvirno kako neki programski jezik funkcioniše moramo znati kojoj paradigmi pripada. Kada kažemo da neki jezik pripada nekoj paradigmi mi zapravo govorimo nešto o karakteristikama tog jezika koje važe za sve jezike koji pripadaju istoj grupi. Programske paradigme su formirane prema načinu programiranja. Neki od najkorišćenijih programskih jezika današnjice spadaju u grupu imperativnih programskih jezika, npr. jezik C. Glavna karakteristika imperativnih programskih jezika je da stanje programa karakterišu promenljive kojima se predstavljaju podaci i naredbe kojima se vrše određene transformacije nad promenljivim (sabiranje, oduzimanje, poređenje, itd.). Osim imperativne, značajne programske paradigme su i
objektno-orijentisana (C++, Java (Java NIJE JavaScript!), C\# itd.), funkcionalna (Lisp, Haskell, ML, itd.), logička (u nju spada, na primer, Prolog). Sa razvojem savremenih programskih jezika došlo je do brisanja jasnih granica između ovih jezika, pa tako dolazi do mešanja karakteristika različitih paradigmi.\\\\
Za većinu programskih jezika danas reći ćemo da su proceduralni. Kada kažemo da je neki jezik proceduralan zapravo želimo da iskažemo činjenicu da je zadatak programera da opiše način (proceduru) kojim će se doći do rešenja problema. Kao idejno potpuno kontrastni, postoje deklarativni programski jezici (poput Prologa) koji od programera zahteva precizan opis problema, a mehanizam programskog jezika se onda bavi pronalaskom rešenja.\\\\
Prema tipu konverzije tipova imamo statički i dinamički tipizirane jezike. Kod statički tipiziranih jezika (poput C-a) zahteva se da programer definiše tip svake promenljive i da ga potom više ne menja tokom izvršavanja programa. Kod dinamički tipiziranih jezika ista promenljiva može sadržati podatke različitog tipa tokom različitih faza izvršavanja. Nekada je moguće čak i vršenje operacija nad promenljivima različitog tipa, pri čemu dolazi do implicitne konverzije. Na primer, jezik JavaScript ne zahteva definisanje tipa promenjlivih i dopušta kôd poput $a = 1; b = "2"; a = a + b;$\\\\

\subsection{Primeri za vežbu}
\begin{primer}
Napisati primer algoritma za kuvanje kafe.
\end{primer}
\begin{primer}
Napisati primer algoritma za provodjenje jednog dana.
\end{primer}
\begin{primer}
Napisati primer algoritma za savladavanje nekog kursa. 
\end{primer}
\begin{primer}
Napisati primer algoritma za računanje zbira prvih 10 parnih brojeva.
\end{primer}
\begin{primer}
Koju vrednost ima promenljiva $x$ nakon izvršavanja narednog koda:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
int x = 0;
if (x > 3);
    x++;
\end{lstlisting}
\end{primer}
\begin{primer}
Napisati pseudo kod za računanje zbira 3 broja.
\end{primer}
\begin{primer}
Napisati pseudo kod u kome se promenljivoj $a$ dodeljuje vrednost $3$, promenljivoj $b$ dodeljuje vrednost $6$ i onda se njihov zbir smešta u promenljivu $c$. Nakon toga, proveriti da li ostatak pri deljenju promenljive (računa se uz pomoć \%) $c$ sa brojem 2 daje 0, odnosno, da li je $c$ paran.
\end{primer}
\begin{primer}
Napisati pseudo kod\footnote{Pseudo kod predstavlja kod koji nije dat u formalnim terminima, već predstavlja ideju kako bi kod trebao da izgleda.} algoritma za računanje zbira prvih 10 parnih brojeva.
\end{primer}
\begin{primer}

\end{primer}

\subsection{Domaći zadatak}
Domaći zadatak:
\begin{itemize}
\item pročitati nešto dodatno o istorijatu računarstva (01\_istorijat), 
\item opisati ukratko svaki od elemenata memorije (01\_piramida),
\item odraditi sve primere i pitalice ,
\item domaci sa osi/tcp slojevima: 01\_osi, 01\_tcp
\item domaci koji je size teksta o browserima: 01\_browser
\item samostalno pronaći još 10 novih i uraditi ih(01\_0,...,01\_9).
\end{itemize}
\newpage
\section{Uvod u web}
\label{sec:uvodweb}
Danas, ne možemo zamisliti korišćenje računara bez veza ka drugim računarima. Izgradnja računarskih mreža, a posebno sa nastankom i razvojem Interneta i njegovih servisa poput Veba, dovele su do porasta broja korisnika računara i promene uloga računara u odnosu na ranije. Pojava savremenih računarskih mreža smatra se revolucionarnom poput pojave parne mašine u $18.$ veku. Svake godine uvećava se broj umreženih računara, a sa tim brojem raste i broj usluga koje nam mrežno okruženje nudi. Neke od osnovnih primera upotreba računarskih mreža obuhvataju:
\begin{itemize}
\item poslovna: elektronska pošta, razmena datoteka, deljeni štampači, ...
\item kućna: filmovi, muzika, igrice, vesti, audio i video komunikacija, razmena poruka, elektronska kupovina,...
\item mobilne: pozivi, SMS, igrice, mape, pristup informacijama
\end{itemize}

\subsection{Uloga računarskih mreža}
U osnovne uloge računarskih mreža ubrajamo:
\begin{enumerate}

\item komunikaciju - uz pomoć računara ljudi razmenjuju poruke, video pozive, mejlove, ćaskanja (eng. chat), video konferencije, itd.
\item deljenje informacija i podataka - ako postoji mrežno okruženje u kom su računari povezani, tada je moguće pristupiti informacijama na drugim računarima u okviru mreže. Podatke prenosimo na više načina, kao što su preuzimanje datoteka, prenos informacija u okviru lokalnih mreža (obično u okviru jedne kompanije), kao i u okviru globalne svetske mreže. Internet i veb se smatraju glavnim izvorima informacija. 
\item deljenje softvera - korisnici povezani u mrežu mogu koristiti mnoge usluge koje im pruža softver koji radi na računarima u okviru mreže. Neke od usluga su kupovina i rezervacija karata preko interneta, ili izvršavanje softvera koji je distribuiran i paralelizovan na više povezanih računara, čime se može ubrzati izvršavanje.
\item deljenje hardverskih resursa - obezbeđuje zajedničko korišćenje hardvera, poput štampača, skenera i ostalih. Često se ovakav pristup koristi u kompanijama.
\end{enumerate} 

Računarski resursi u mreži mogu biti raspoređeni na različite načine, tako da obezbeđuju različite načine izvršavanja poslova. Neki od najčešćih su:
\begin{itemize}
\item Centralizovana obrada - svi poslovi se izvršavaju na jednom centralnom računaru, dok se ostali uređaji u mreži koriste samo kao terminali za unos podataka i prikaz rezultata. Ovakavim načinom rada odlikovale su se rane računarske mreže.
\item Klijent-server okruženje - jedan računar ima ulogu servera na kome se nalaze
podaci i aplikativni softver, koji se stavljaju na raspolaganje klijentima. Serveri su obično moćniji računari od klijenata(mada ne mora uvek biti tako) i na njima se obavljaju zadaci koji zahtevaju više resursa. U današnjem kontekstu, stroga podela na klijentski i serverski računar više nije tako aktuelna. Najčešće govorimo o tome da je jedan računar istovremeno i klijent i server u zavisnosti od zadataka koji su mu zadati. Na primer, isti računar može istovremeno pokretati i Veb server i klijent za elektronsku poštu, čime mu je data i uloga servera i uloga klijenta.
na njihov zahtev. 
\item Mreža ravnopravnih računara (eng. peer-to-peer - $P2P$) - računari direktno komuniciraju deleći podatke i opremu. Sve se češće ovakve mreže koriste za masovnu razmenu velikih količina podataka (npr. torenti - Bittorrent).
\end{itemize}
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/KS.png}
\end{center}
\caption{Prikaz klijent-server arhitekture.}
\label{fig:KS}
\end{figure}

\subsection{Komponente računarskih mreža}
Pre nego što uđemo u detaljniji opis elemenata koji čine jednu računarsku mrežu, trebalo bi da damo formalnu definiciju šta je računarska mreža. Naime, računarska mreža je sistem koji se sastoji iz skupa hardverskih uređaja koji su međusobno povezani komunikacijskom opremom i koji je snabdeven odgovarajućim kontrolnim softverom kojim se ostvaruje kontrola funkcionisanja sistema tako da je moguć prenos podataka između povezanih uređaja. Neke od osnovnih komponenti računarskih mreža su, dakle:
\begin{itemize}
\item mrežni hardver, 
\item komunikacioni kanali i 
\item mrežni softver.
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/PrMr.png}
\end{center}
\caption{Prikaz mreže.}
\label{fig:PrMr}
\end{figure}

\subsubsection{Mrežni hardver}
Tradicionalno, podrazumeva se povezivanje računara u okviru mreže, ili uz dodatak nekih pomoćnih uređaja poput štampača, skenera itd., kako bi se mogli deljeno koristiti. Međutim, u poslednje vreme, granica između klasičnih računara i digitalnih uređaja specijalizovane namene se briše i sve češće se u oviru mreže mogu povezati i PDA uređaji, mobilni telefoni, foto aparati, kamere i ostali. Aktivno se radi i na razvoju automobila, frižidera i ostalih mnogobrojnih uređaja kako bi se uključili u mrežu i kako bi se time omogućilo upravljanje istima na daljinu.\\\\
Da bismo neki uređaj mogli da ubacimo u mrežu, neophodno je da sadrži određene hardverske komponente koje bi mu to omogućile. Deo hardvera koji je namenjen za umrežavanje i spada u komunikacionu opremu je mrežna kartica ili mrežni adapter (eng. NIC - network interface card) koja omogućava fizički pristup mreži. Svaka mrežna kartica ima svoju jedinstvenu fizičku (MAC) adresu, kojom se uređaj jedinstveno identifikuje prilikom komunikacije. Neke mrežne kartice obezbeđuju pristup žičanim, a neke druge bežičnim komunikacionim kanalima. Osim mrežnih kartica za umrežavanje se koriste i modemi (telefonski, kablovski), kao i još neki uređaji o kojima neće biti reči. 
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.25]{pictures/mreznakartica.jpg}
\end{center}
\caption{Prikaz mrežne kartice.}
\label{fig:mk}
\end{figure}


\subsubsection{Komunikacioni kanali}
Da bi mreža funkcionisala i da bi kroz nju bilo moguće preneti podatke, uređaji koji se nalaze u mreži moraju biti povezani međusobno uz pomoć žičanih ili bežičnih prenosnih sistema, koji predstavljaju komunikacione kanale. Osnovna mera kvaliteta komunikacionog kanala je brzina prenosa koja se meri u bitovima po sekundi (bit/s). Ova mera označava broj bitova koji se mogu preneti kroz komunikacioni kanal u jednoj sekundi. Ako bismo posmatrali aktuelne tehnologije prenosa podataka, najčešće se koriste megabiti ( milion bita) u sekundi - Mbps, ili gigabiti (milijarda bita) u sekundi - Gbps. Brzina prenosa predstavlja fizičku karakteristiku komunikacionog kanala i zavisi od frekvencijskog opsega (eng. bandwidth) koji se može propustiti kroz kanala bez gubitka signala. Na slici \ref{fig:opseg} prikayan je raspon frekvencija za razne prenosne tehnologije. \\\\

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.7]{pictures/bandw.png}
\end{center}
\caption{Prikaz frekvencijskih opsega za razne prenosne tehnologije.}
\label{fig:opseg}
\end{figure}

Komunikacione kanale možemo podeliti u dve grupe prema tipu prenosa informacija:
\begin{enumerate}
\item Žičane  
\item Bežične 
\end{enumerate}

\subparagraph{Žičane komunikacije} 
\subparagraph{Parice}(eng. twisted-pair wire) - Najkorišćeniji način komunikacije. Uređaji se povezuju korišćenjem uvijenih uparenih izolovanih bakarnih žica. Žice se uparuju i uvijaju kako bi se smanjile smetnje u komunikaciji. Brzina prenosa kroz ovakav medijum obično varira od $2Mbps$ do $100Mbps$.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/twpw.jpg}
\end{center}
\caption{Prikaz parice.}
\label{fig:twpw}
\end{figure}

\subparagraph{Koaksijalni kablovi} svoju upotrebu najčešće nalaze u televizijskim kablovskim sistemima, a koriste se i u lokalnim mrežama u kompanijama. Kablovi se sastoje od centralne bakarne ili aluminijumske žice obmotane savitljivim slojem izolacije, oko kog je obmotan provodni sloj tankih žica, a potom je sve to izolovano. Ovaj tip kablova omogućava brzinu prenosa do $200Mbps$ (nekad čak i do $500Mbps$), uz manju osetljivost na elektromagnetne smetnje. 

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/coax.jpg}
\end{center}
\caption{Prikaz koaksijalnog kabla.}
\label{fig:coax}
\end{figure}

\subparagraph{Optički kablovi}- prave se od velikog broja (reda veličine nekoliko stotina ili hiljada) veoma tankih staklenih vlakana. Podaci se prenose svetlosnim talasima uz pomoć malog laserskog uređaja. Na ovaj tip kablova elektromagnetne smetnje nemaju uticaja. Najveći nedostatak ovakvih kablova je cena, izuzetno su skupi i komplikovani za komunikaciju, pa se uglavnom koriste za osovinski deo mreže, na koji se potom drugim vrstama kablova povezuju pojedinačni uređaji. Brzina ovih uređaja predstavlja njihovu najveću prednost. Naime, brzina ovih uređaja može ići i do nekoliko triliona bita u sekundi. Najčešće se koriste za mreže sa brzinama do $10 Gbps$.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/optical.jpg}
\end{center}
\caption{Prikaz optičkog kabla.}
\label{fig:optical}
\end{figure}

\subparagraph{Bežične komunikacije}
Bežična komunikacija, kao što i samo ime sugeriše, ne koristi kablove za prenos podataka. Ovakav vid komunikacije poseban značaj nalazi kod prenosivih računara, mobilnih telefona ili dosta udaljenih lokacija do kojih bi bilo jako skupo, ako ne i nemoguće, sprovesti kablovsku mrežu. Umesto kablova ove mreže koriste radio talase, mikro talase i infracrvene zrake. Podaci se prenose moduliranjem amplitude, frekvencije ili faze talasa. Neke od danas najkorišćenijih tehnologija su: 
\begin{itemize}
\item Bluetooth - koristi se za veoma male razdaljine (do $10$ ili do $100$ metara. Brzina prenosa je do $3Mbps$. Bluetooth tehnologija koristi radio talase i može da prođe i kroz čvrste prepreke. Koristi se najčešće za komunikaciju računara sa periferjskim uređajima, kao i u mobilnoj telefoniji.
\item Bežični LAN - Wireless LAN (WLAN, WiFi) je tehnologija koja korsti radio talase za bežičnu komunikaciju više uređaja na ograničenim rastojanjima (nekoliko desetina ili stotina metara). Brzina prenosa ide od $10Mbps$ do $50Mbps$ ( u skorije vreme može ići i do $600Mbps$). Najrašireniji standard za ovaj vid komunikacije je IEEE $802.11$, o kome će kasnije biti više reči. 
\item Ćelijski sistemi - Način prenosa je sličan onom koji se koristi u mobilnoj telefoniji. Za komunikaciju se koriste radio talasi i sistemi antena koji pokrivaju određenu geografsku oblast, pri čemu se signal do cilja prenosi preko niza antena. 
\item Zemaljski mikrotalasi - koriste antensku mrežu na Zemlji, a za komunikaciju koriste mikrotalase niske frekvencije koji zahtevaju da antene budu optički vidljive, pa se iste smeštaju na visoke tačke. 
\item Komunikacioni sateliti - koriste mikrotalase za komunikaciju tako što se prenos između dve tačke koje nemaju optičku vidljivost ostvaruje poprečnom komunikacijom preko satelita koji se nalaze u orbiti. Na ovaj način se prenose televizijski i telefonijski signal. Brzina komunikacije je dosta mala $100Mbps$.
\end{itemize}

\subsubsection{Mrežni softver}
Mrežna infrastruktura sama po sebi ne služi ničemu bez mrežnog softvera. Uloga mrežnog softvera je da obezbedi korisniku mrežnu komunikaciju. Na primer, programer pregledača Veba, ne treba da misli o tome kako će pregledač primiti informacije, već treba da se fokusira samo na aspekte značajne za njegovu konkretnu aplikaciju, a sve ostale detalje prepusti nižem sloju mrežnog softvera.

Mrežni softver, najgrublje, može da se podeli na dva nivoa:
\begin{itemize}
\item niskog nivoa - mrežni softver koji omogućuje korišćenje različitih mrežnih uređaja, poput mrežnih kartica, modema, itd. Ovaj softver se nalazi u jezgru operativnog sistema i u obliku upravljača perifernim uređajima, takoznavnih drajvera (eng. driver). On upravlja računarskim hardverom i komunikacijskom opremom. Korisnik nikad ne koristi ovaj softver direktno, a često nije ni svestan njegovog postojanja 
\item visokog nivoa.
\end{itemize}

\subsection{Literatura}
Čitanje literature predstavlja neizostavan deo gradiva, kako naredni izvori predstavljaju odlican izvor informacija, na vama je da ih procitate:
\begin{itemize}
\item Predrag Janičić, Programiranje 1, Matematički fakultet, glava 1
\item Filip Marić, Uvod u web i internet tehnologije, Matematički fakultet, glave 1 i 2
\item Ajzenhamer Nikola, Bukurov Anja, Stanković Vojislav, Programiranje za Veb skripta, glave 1,2 i 3
\end{itemize}
\newpage

\section{HTML i CSS}
\label{sec:htmlcss}
HTML i CSS predstavljanju neizostavan materijal pri učenju web programiranja. Upravo zbog njihovog velikog značaja im posvećujem celo poglavlje. Slajdovi korišćeni prilikom predavanja su apsolutno nedovoljan materijal. Svi materijali korišćeni pri kreiranju časova, kao i ovog materijala su javno dostupni i nalaze se na:
\begin{itemize}
\item Aleksandar Veljković, Veb programiranje, Matematički fakultet http://poincare.matf.bg.ac.rs/~aleksandar/files/web/skripta.pdf
\item W3Schools: https://www.w3schools.com/
\item Filip Marić, Uvod u Veb i Internet tehnologije, Matematički fakultet 
\end{itemize}

\subsection{HTML}
\subsubsection{Zadaci sa časa}
Neki od zadataka rađenih na času su navedeni u nastavku.

\begin{primer}
Prva HTML stranica: Treba kreirati svoju prvu HTML stranicu korišćenjem tagova. Propozicije stranice su sledeće:
\begin{itemize}
\item Kreirati naslov stranice i iskoristiti barem 3 nivoa heading-a
\item Napisati neki pasus koji ima smisla, u okviru kog treba iskoristiti break, strong i em tagove
\item Potom kreirati isto to za ostale nivoe headinga
\item Kreirati jos barem 3 stranice, od čega: 2 treba da sadrže smisleni tekst u paragrafima, a poslednja može sadržati tekst u vidu \textit{lorem ipsum dolor sit...}
\item Druga strana treba da sadrži linkove ka barem 3 spoljašnje strane, npr: ujutru uz kafu volim da čitam, pa linkove ka nekoliko portala
\item Svaka strana treba da sadrži veze ka svim ostalim stranama
\end{itemize}
\end{primer}

\begin{primer}
Španska kuhinja: Kreirati sajt prema sledećim propozicijama:
\begin{enumerate}
\item Iz kojih jela se sastoje tipični obroci u Španiji (entrada, primer plato, segundo plato,...)?
\item Kreirati osnovnu stranicu sa opisom delova obroka, a potom za svaki deo obroka kreirati posebnu stranicu.
\item Svaka stranica mora da sadrži
	\begin{itemize}
		\item Naslov, npr.: Primer plato
		\item Podnaslov, naziv nekog tipičnog jela karakterističnog za taj obrok, npr.: Nachos (za entradas)
		\item Pasus, nešto o tom jelu, odakle je poteklo, kad je nastalo  i slično
		\item Pasus sa neuređenom listom potrebnih sastojaka
		\item Pasus sa uređenom listom postupka pripreme
	\end{itemize}
\item Nekoliko slika jela
\item Vezu ka prethodnoj i narednoj stranici
\item Poslednja stranica treba da se vraća na prvu i da ima spoljašnju vezu ka opisu nekog grada u Španiji.
\end{enumerate}
\end{primer}
\begin{primer}
Sportski izveštaj: Kreirati stranicu o sportu. Odabrati sport po izboru, a potom ispuniti specifikaciju:
\begin{enumerate}
\item Napraviti definicionu listu koja opisuje odabrani sport
\item Napraviti listu sa pravilima igre, ako je moguće kreirati listu u listi (ugnježdena lista)
\item Kreirati tabelu sa rezultatima nekog takmičenja
\item Ubaciti dve ili više slika (iskoristiti width i height kako bi se veličina slike prilagodila)
\item Ubaciti tabelu sa rezultatima sa nekog većeg takmičenja iz tog sporta
\end{enumerate}
\end{primer}
\begin{primer}
Stiven Hoking: Kreirati sajt koji će sadržati informacije o Stivenu Hokingu (eng. Stephen Hawking).
Specifikacija sajta je sledeća:
\begin{itemize}
\item Sajt treba da sadrži naslov, kome će u tooltip-u stajati: engleski teoretski fizičar, kosmolog, autor i direktor istaživanja u Centru za teorijsku kosmologiju na Univerzitetu u Kembrdžu.
\item Ispod naslova treba da stoji kratki paragraf o Stivenu Hokingu, paragraf treba da sadrži boldovan i italic tekst, kao i nešto što bi bilo highlightovano i precrtano
\item Kreirati listu sa spiskom njegovih publikacija
\item Ubaciti sliku, i skalirati je korišćenjem odgovarajućih atributa
\item Ubaciti neki citat na odgovarajući način
\item Ubaciti citat nečega sa njegove stranice, i potom referisati stranicu.
\item Ubaciti vezu ka drugoj stranici na kojoj će biti slike i nazivi nekih od njegovih publikacija
\end{itemize}
\end{primer}

\begin{primer}
Forma za registraciju za učešće na nekom kursu. Zadatak je kreirati stranicu koja će sadržati formu, koja bi trebalo da se popuni kako bi se prijavilo za učešće na nekom od kurseva. Sami odaberite nazive kurseva, kao i relevantne informacije polaznika.
\begin{itemize}
\item Ime
\item Prezime
\item Adresa
\item Grad
\item Broj telefona
\item Broj mobilnog
\item e-mail adresa
\item kurs za koji se prijavljuje - lista od barem 5 izbora
\item odabir termina: vikendom, radnim danima ili svejedno - radio buttoni
\item checklista: radim na svom računaru/ potreban mi je računar
\item text area u kojoj treba upisati prethodno iskustvo
\item button za slanje informacija
\end{itemize}
Neke od informacija o polaznicima kurseva su obavezne, neke nisu, sami odredite koje jesu. Osim navedenih treba dodati jos barem 2 dodatne informacije po izboru u različitim oblicima.
\end{primer}

\subsection{CSS}
\subsubsection{Zadaci sa casa}

\begin{primer}
Kreirati stranicu zdrave hrane.
\end{primer}

\subsubsection{Domaći zadaci}
Domaći zadaci vezani za ovo poglavlje se odnose na unapređivanje i dodavanje sadržaja i isprobavanje tagova i elemenata nad zadacima rađenim na časovima. 

\newpage

\section{JavaScript}
\label{sec:javascript}

JavaScript (skraćeno JS) je skript jezik, nastao $1995$. godine kao jezik za pregledač Netscape Navigator kako bi se omogućile programske sposobnosti veb stranicama. Osnovna uloga JavaScripta na Vebu je programiranje korisnickog interfejsa. ECMAScript standard je standard kojim se definiše ponašanje svih pregledača koji podržavaju JavaScrpit. Bitno je naglasiti da programi napisani jezikom Javascript se izvršavaju na klijentskoj mašini (iako postoje i upotrebe na serveru). Uz HTML i CSS, JS predstavlja jezgro tehnologija korišćenih na Vebu.

\subsection{Osnovni konstrukti jezika}
Pod osnovne konstrukte jezika podrazumevamo minimalan skup neophodnih znanja i pravila potrebnih za rad u određenom programskom jeziku. Osnovni konstrukti su idejno veoma slični, pa i isti, za većinu viših programskih jezika i dobrim poznavanjem osnova barem jednog programskog jezika višeg nivoa, moguće je dosta lako savladavanje i ostalih. U ovom delu biće predstavljeni osnovni konstrukti jezika vezani konkretno za JavaScript.\\\\
JavaScript kod možemo ubaciti u postojeću HTML datoteku na naredna dva načina:
\begin{itemize}
    \item kao novu datoteku u headu: <script src='datoteka.js'></script> 
    \item kroz HTML, na kraju body-ja, između <script> tagova.
\end{itemize}

\subsubsection{Promenljive i tipovi}
Nakon što smo na odabrani način obezbedili prostor za unošenje JS koda, želimo da kreiramo neku promenljivu. Za JS se kaže da je slabo tipiziran jezik, to znači da tip promenljive koju kreiramo ne zadajemo eksplicitno, već je on određen tipom vrednosti koju ta promenljiva čuva. Veoma bitno je naglasiti da se sa promenom sadržaja promenljive menja i njen tip u toku izvršavanja programa. Ako bismo na primer u promenljivu $a$ stavili broj $13$, a kasnije stavili nisku $"$programer$"$, promenljiva $a$ bi najpre imala tip $number$, a potom $string$.\\\\
Postoji nekoliko različitih tipova koje možemo smestiti u promenljivu, to su:
\begin{enumerate}
    \item Brojevi: 
    \begin{itemize}
        \item celi brojevi: ...,-10, -5, 0, 1, 7, 13,...
        \item razlomljeni brojevi: 3.14, 9.81, ...
        \item beskonačnosti: Infinity, -Infinity
        \item NaN - not a number - označava da nešto nije broj, dobija se kao rezultat nedefinisanih operacija (0/0, Infinity/Infinity,...) 
    \end{itemize}
    \item Niske (stringovi) - predstavljaju nizove karaktera: $"$ Mi volimo programiranje $"$
    \item Bulove vrednosti: True, False
    \item Prazne vrednosti: null, undefined
\end{enumerate}
U nastavku će biti ukratko opisano kreiranje, korišćenje i osnovne operacije nad navedenim tipovima. U promenljive je moguće smestiti i složenije tipove kao što su nizovi, objekti i drugi, o kojima će, takođe, biti reči u nastavku.\\\\
Kako bismo kreirali promenljivu u programu, navodimo ključnu reč $var$ (postoje jos neke ključne reči za kreiranje promenljivih, ali će o njima biti reči kasnije), a potom naziv promenljive, koji ne sme počinjati brojem ili biti ključna reč jezika.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a;
\end{lstlisting}
Ovako smo samo kreirali promenljivu, ona za sada nema nikakvu vrednost u sebi, a samim time i njen tip nije definisan. Kada želimo da promenljivoj dodelimo neku vrednost to činimo korišćenjem naredbe dodele $*$, pa tako sa
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
a = 5;    
\end{lstlisting}
smeštamo celi broj 5 u promenljivu a, i njen tip postaje $number$.
Moguće je i pri kreiranju odmah dodeliti vrednost promenljivoj $a$, ovaj postupak nazivamo inicijalizacijom ili dodeljivanjem početne vrednosti promenljivoj.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 5;    
\end{lstlisting}
JavaScript dopušta još jednu stvar, a to je kreiranje promenljive bez navođenja ključne reči var ukoliko bismo joj odmah dodelili vrednost. Napomena: ovo se ne smatra dobrom praksom, a ukoliko bi stajalo samo b bez $var$ i bez $*7$ program bi izbacio grešku.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
b = 7;    
\end{lstlisting}
Kada se dodeljuju nazivi promenljivim treba obratiti pažnju da nazivi nisu ključne reči jezika, kao i da ne počinju brojem.\\\\

\subparagraph{Brojevi}
U JavaScript-u možemo predstaviti cele brojeve - int: -1, -32, 0, 13, 173,itd., kao i razlomljene brojeve - float: 3.14, 9.81,itd..
Da bismo broj smestili u neku promenljivu koristimo operator dodele.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 5; 
\end{lstlisting}
Osim operatora dodele $=$, postoje i drugi operatori. Najčešće operatore primenjujemo nad brojevnim (numeric) vrednostima. Nad numeričkim vrednostima definisani su:
\begin{itemize}
    \item Unarni $-$: $-4$
    \item Binarni $+$, $-$, $*$, $/$, $\%$, $=$, $<$, $>$, $<=$, $>=$
\end{itemize}
Ovi operatori imaju standarne prioritete. Operator $\%$ predstavlja ostatak pri deljenju dva broja.\\
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var c = a + b; //12
\end{lstlisting}
Osim ovih binarnih operatora postoje i binarni operatori za proveru jednakosti $==$, nejednakosti $!=$, za proveru jednakosti sa proverom tipova $===$, operatori koji vrše konjunkciju $\&\&$ i disjunkciju $||$, kao i složeni operatori ++(unarni), +=, -=, *=,itd.. O njima će biti više reči u nastavku. \\\\
Da bismo broj zapisali sa određenim brojem decimala koristimo metod\footnote{Metodi su, za sad, crne kutije koje nam omogućavaju da vršimo određene promene nad promenljivim. U nastavku će biti detaljnije obrađene.} $toFixed()$, kome kao jedini argument šaljemo broj decimala koji želimo da zadržimo. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var pi = 3.1415;
pi = pi.toFixed(2); // pi = 3.14
\end{lstlisting}
\paragraph{Pisanje komentara}
Pisanje komentara predstavlja dobru praksu i može biti od velike pomoći programeru. Najčešće se radi nad nasleđenim kodovima, koje su pisali programeri pre nas, pa tako komentari mogu dosta olakšati rad i razumevanje koda. Osim toga, vrlo često prilikom vraćanja na ranije pisane kodove, dešava se da nismo sigurni kako smo nešto napisali, iako nam je u datom momentu to delovalo sasvim jednostavno i logično, pa nam komentari mogu pomoći da se prisetimo šta je bila glavna ideja. U početničkom programiranju, komentari pomažu kako bi se neki koncepti utvrdili, dodatno razjasnili i definisali, pa autor predlaže pisanje komentara što češće.\\\\ 
Komentari mogu biti: linijski i blokovski. Linijski komentari, kao što im i samo ime kaže imaju doseg jedne linije (koja ne bi trebalo prema konvenciji da sadrži više od 80 karaktera!) i pišu se nakon znaka $//$. Blokovski komentari imaju doseg od više linija i pišu se između $/**/$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//ovo je linijski komentar
/*Ovo 
je 
blokovski*/
var c = a + b; //12
\end{lstlisting}

\paragraph{Konzola}
Konzola omogućava programeru lakše debagovanje koda, lakše pronalaženje grešaka, izbacuje greške, upozorenja i obaveštenja.
U konzoli, takođe, možemo ispisati rezultate nekih izvršavanja programa, vrednosti i tipove promenljivih itd.\\
Da bismo to postigli, moramo najpre otvoriti konzolu, to se radi uz pomoć $F12$. Konzola je, najverovatnije, trenutno prazna. Kako bismo ispisali neki tekst u nju koristimo neke od sledećih funkcija:
\begin{itemize}
    \item console.log()
    \item console.warn()
    \item console.error()
    \item console.info()
\end{itemize}
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var c = a + b; //12
console.log(c); //ovime ispisujemo 12 u konzolu
\end{lstlisting}
\textbf{Operator typeof} služi kako bi se ispisao tip promenljive.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var c = a + b; //12
console.log(typeof c); //ispis tipa promenljive c u konzolu - numeric
\end{lstlisting}
Možemo nadovezati i više argumenata pri ispisu u konzolu odvajajući ih zarezom. Korišćenjem zareza kreira se razmak između argumenata.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var c = a + b; //12
console.log("Vrednost zbira je", c); 
\end{lstlisting}

\subparagraph{Prazne vrednosti}
Pod prazne vrednosti ubrajamo $null$ i $undefined$. One služe da označe odsustvo postojanja vrednosti. U daljem tekstu, susretaćemo se sa ovim vrednostima.

\subsubsection{Naredbe za kontrolu toka}
Osnovni elementi za opis izračunavanja u programima nazivaju se naredbe (već smo videli naredbu dodele).
Naredbe za kontrolu toka omogućavaju različite načine izvršavanja programa, u zavisnosti od vrednosti promenljivih. Naredbe za kontrolu toka mogu biti:
\begin{itemize}
\item naredbe grananja i 
\item petlje.
\end{itemize}
Osnovni oblik naredbe koji se javlja je takozvana naredba izraza (ova vrsta naredbi obuhvata i naredbu dodele i naredbu poziva funkcije).
Naime, svaki izraz završen karakterom ; je naredba. Na primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
3 + 4*5;
n = 3;
c++; //uvecanje promenljive za 1, isto kao c = c + 1
f();	
\end{lstlisting}
Nekada, želimo da više različitih naredbi grupišemo i da ih tretiramo kao jednu jedinstvenu naredbu. Vitičaste zagrade { i } se koriste da grupišu naredbe u složene naredbe, odnosno blokove, i takvi blokovi se mogu koristiti na svim mestima gde se mogu koristiti i pojedinačne naredbe. 

\subparagraph{Naredbe grananja} (ili naredbe uslova), na osnovu vrednosti nekog izraza, odreduju naredbu (ili grupu naredbi) koja će biti izvršena.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if (izraz)
    naredba1
else
    naredba2
\end{lstlisting}
Konkretno, na primeru kroz jezik JavaScript:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//primer ispisuje veci od dva broja
if (a > b)
    console.log(a);
else
    console.log(b);
\end{lstlisting}
Naredbe $naredba1$ i $naredba2$ su ili pojedinačne naredbe (kada se završavaju simbolom ;) ili blokovi naredbi zapisani između vitičastih zagrada (na kraju kojih ne ide ;).
Deo naredbe $else$ je opcioni, odnosno, ne mora postojati, pa se može napisati samo $if$ grana.
Izraz $izraz$ predstavlja logički uslov:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if (5 > 7)
   a = 1;
else
   a = 2;


if (7)
    a = 1;
else 
    a = 2;
    
a = 3;
if (a = 0)
    console.log("a je nula\n");
else
    console.log("a nije nula\n");
\end{lstlisting}


Često možemo imati višestruke odluke, za šta koristimo $else\ if$ konstrukciju oblika:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if (izraz1)
    naredba1
else if (izraz2)
    naredba2
else if (izraz3)
    naredba3
else
    naredba4
\end{lstlisting}

\begin{primer}
Primer $else\ if$ naredbe.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if (a > 20)
   console.log("A je vece od 20\n");
else if (a > 10)
   console.log("A je vece od 10\n");
else if (a < -20)
   console.log("A je manje od -20\n");
else if (a < -10)
   console.log("A je manje od -10\n");
else
   console.log("A pripada intervalu [-10, 10]\n");
\end{lstlisting}
\end{primer}

Ternarni operator je uslovni operator oblika: $uslov\ ?\ ispunjen\ :\ inace$ i ima isto značenje kao i if else. 
\begin{primer} Zadatak je smestiti veći od dva broja u promenljivu $x$. Prvi if else ima isto značenje kao i ternarni operator koji smešta veći broj u $x$. Ako je $a$ vece od $b$ postavlja se $x$ na $a$, inače postavlja se na $b$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if (a > b)
   x = a;
else
   x = b;
x = (a > b) ? a : b;
\end{lstlisting}
\end{primer}
Osim $if$-$else$ postoji i naredba $switch$, koja se takođe može koristiti za višestruko odlučivanje i ima opšti oblik:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
switch (izraz) {
  case konstantan_izraz1: 
  	naredbe1;
  	break;
  case konstantan_izraz2: 
  	naredbe2;
  	break;
  ...
  default: 
    naredbe_n;
    break;
}
\end{lstlisting}
$Case$ predstavljaju slučajeve, koji ako su ispunjeni, izvršava se naredba desno od dvotačke. U slučaju da nijedan od case-ova nije ispunjen izvršava se default, ako default nije postavljen i nijedan od case-ova nije ispunjen kroz switch će se samo proći.

\subparagraph{Petlje}(ciklusi ili repetitivne naredbe) uzrokuju da se određena
naredba (ili grupa naredbi) izvršava više puta (sve dok je neki logički uslov ispunjen).
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
while(izraz)
   naredba
   
while (i < j)
   i++;
   
while (1)
   i++;
   
for (izraz1; izraz2; izraz3)
   naredba

izraz1;
while (izraz2) {
   naredba
   izraz3;
}

for(i = 0; i < n; i++)
...
\end{lstlisting}

Postoji još jedan vid petlje, to je petlja do-while.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
do {
naredbe
} while(izraz)
\end{lstlisting}
Telo (blok naredbi naredbe) naveden izmedu vitičastih
zagrada se izvršava i onda se izračunava uslov (izraz $izraz$).
Ako je on tačan, telo se izvršava ponovo i to se nastavlja sve
dok izraz $izraz$ nema vrednost nula (tj. sve dok njegova
istinitosna vrednost ne postane netačno).
Za razliku od petlje while, naredbe u bloku ove petlje se uvek
izvršavaju barem jednom. Navođenje vitičastih zagrada pri korišćenju naredbi za kontrolu toka smatra se dobrom programerskom praksom.\\\\

U nekim situacijama pogodno je napustiti petlju ne zbog toga
što nije ispunjen uslov petlje, već iz nekog drugog razloga. To
je moguće postici naredbom break:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
for(i = 1; i < n; i++) {
    if(i > 10)
       break;
    ...
}
\end{lstlisting}
Naredbom continue se prelazi na sledeću iteraciju u petlji.
Na primer,
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
for(i = 0; i < n; i++) {
   if (i % 10 == 0)
      continue; /* preskoci brojeve deljive sa 10 */
   ...
}
\end{lstlisting}
Petlje i uslovne naredbe se mogu kombinovati, korišćenjem jednih u drugima i slično.
U slučaju ugnježdenih petlji, naredbe break i continue imaju
dejstvo samo na unutrašnju petlju.
\subparagraph{Bulove vrednosti}
Pod Bulovim vrednostima smatramo $true$ i $false$, odnosno tačno i netačno, $1$ i $0$. 
Ako bismo hteli da kreiramo beskonačnu petlju (iako se to nikako ne preporučuje) bio bi nam potreban uslov koji uvek važi:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
while(true){
   //radi nesto zauvek
}
if(false)
    console.log("Ovo se nece nikad ispisati");
if(true)
    console.log("Ovo ce se uvek ispisati");
var a = 10;
var b = -10;
if((a != b) == true){
    console.log("uslov da su a i b razliciti vazi");
}
\end{lstlisting}
Ako bismo hteli da nadovežemo više uslova, ili da kažemo da želimo da se nešto izvrši ako je bilo koji od uslova ispunjen koristimo binarne operatore $\&\&$ i $||$, odnosno $"$logičko i$"$ i $"$logičko ili$"$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 10;
if(a > 0 && a%2==0)
   console.log("a je paran broj veci od 0.);
var b = -10;
if(a > 0 || b > 0 )
   console.log("Ako je ili a ili b vece od 0 ovo ce se ispisati);
\end{lstlisting}
Napomena: uslova može biti više od 2.


\subparagraph{Prozori}
Često se javlja potreba da korisnika stranice obavestimo o nečemu. Ono što nam JS omogućava je da na jednostavan način uz pomoć \textbf{alert} funkcije, korisniku jasno prikažemo poruku, koju ne može da ignoriše. Jedini argument ove funkcije je niska koja se prikazuje korisniku. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
alert("Ovo je iskacuce obavestenje");
\end{lstlisting}
Nekada se od korisnika zahteva da na neko pitanje odgovori pozitivno ili negativno, za šta se koristi funkcija \textbf{confirm}. Argument ove funkcije je isti kao kod $alert$. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
confirm("Da li ste sigurni?");
\end{lstlisting}
Ukoliko bi se od korisnika očekivao unos nekog teksta, za to može da se koristi funkcija \textbf{prompt}. Argumenti ove funkcije su niska koja se ispisuje u prozoru i podrazumevana vrednost polja za unos. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
prompt("Unesite broj godina:");
\end{lstlisting}
\subparagraph{Vežba}
Uraditi zadatke iz uvodne sekcije.

\subsubsection{Niske}
Niske ili stringovi, predstavljaju nizove karaktera. U promenljivu možemo smestiti pojedinačni karakter, a možemo i čitave reči ili rečenice. \\
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 'abc'; //a je niska
a = 'a'; // a je sada karakter
\end{lstlisting}
Niske se mogu navoditi između $"$ (dvostrukih), $'$ (jednostrukih), kao i $`$ iskošenih navodnika (šablon-literali, engl. template literals).  
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var niska1 = "Ovo je prva niska.";
var niska2 = "Ovo je druga niska";
var niska3 = `Ovo je niska
              neka treca`;
\end{lstlisting}
Primetimo da šablon literali poštuju novi red. Važno je naglasiti da se mora obratiti pažnja na to da navodnici budu pravilno upareni. Naime, program se neće izvršavati na predviđeni način ukoliko, na primer, nakon dvostrukog navodnika pokušamo nisku da zatvorimo jednostrukim navodnikom.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var niska1 = "Ovo je prva niska.";
var niska2 = "Ovo je druga niska";
var niska3 = "Ova niska nije pravilna';
\end{lstlisting}

Ukoliko želimo da unutar niske imamo prave navodnike (na primer kod citata), onda možemo ili upotrebiti drugi vid navodnika ili koristiti escape sekvencu \textbackslash. Kako bismo nadovezali dve niske koristimo operator $+$, a ovaj postupak se naziva $konkatenacija$. Treba obratiti pažnju na to da nadovezivanjem niski sa $+$, ne dobijamo razmak između stringova kao kod korišćenja $,$. Da bismo dobili razmak moramo ga dodati kao još jednu nisku, a kako bismo dobili novi red koristimo \textbackslash$n$. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(niska1 + niska2); 
niska1 = 'Ovo je neka niska.';
niska1 = 'Kaze Bob: "Alice ne kradi"';
console.log(niska1);
niska2 = 'Kaze Alice: \'Sta cu moram\' \nAlice nikad nije imala \nnameru
da ukradene podatke zloupotrebi.';
console.log(niska2); 
niska2 = 'It\'s mine';
console.log(niska2);
niska2 = `Kaze Alice:
          'Necu vise krasti'
          Ukrala sam samo ${2 + 2} jabuke.`;
\end{lstlisting}
Ako bismo pokušali da na niske nadovežemo numeričke vrednosti, one bi se ponašale kao niske, osim ako bismo ih izdvojili zagradama.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log("Zbir 1 i 2 je: " + 1 + 2); //12
console.log("Zbir 1 i 2 je: " + (1 + 2)); //3
console.log(`Zbir 1 i 2 je: ${1 + 2}`);  //3
\end{lstlisting}
Primetimo da pri korišćenju šablon literala ono što želimo da se sračuna navodimo između $\$\{\}$.
Nekada želimo da nisku posmatramo kao broj, da bismo eksplicitno kastovali (izvršili pretvaranje, eksplicitnu konverziju) niske u broj, koristimo funkcije $parseInt()$ i $parseFloat()$, koje prave ceo broj ili razlomljen broj redom. U slučaju da niska osim brojeva sadrži i neke druge karaktere, biće pokupljeni samo brojevi koji se nalaze na početku niske. Na primer, za nisku $"$123.292ajkula$"$ parseInt će uzeti samo broj 123 (zaključno sa tačkom, jer je Int ceo broj), parseFloat će uzeti 123.292, a ostatak će biti ignorisan. Ako bi niska bila $"$a123.292$"$ ništa ne bi bilo pokupljeno i funkcije bi vratile NaN ($"$Not a Number$"$). 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var p = "5";
console.log(typeof p); //string
console.log(typeof parseInt(p)); //number
\end{lstlisting}
Poređenje niski vrši se leksikografski uz pomoc operatora $>$,$<$,$>=$ i $<=$, kao i uz pomoć operatora $==$, $!=$ ili $===$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
if("ana" >= "ane"){
   console.log("ana");
}
else{
   console.log("ane");
}
\end{lstlisting}

Metodom toString() vršimo eksplicitno konvertovanje u nisku.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var br_u_str = 102;
console.log("Tip promenljive je :", typeof br_u_str);
br_u_str = br_u_str.toString();
console.log(br_u_str);
console.log("Metod toString() vraca",typeof br_u_str);
\end{lstlisting}

\subparagraph{Implicitna konverzija}
JavaScript je programski jezik takav da može da "progura" razne konstrukte, sa ciljem da program izvrši, zbog toga se često javljaju neki više ili manje očekivani rezultati. Implicitna konverzija je postupak pri kom program sam vrši konvertovanje nekog tipa u neki drugi tip kako bi dobio nešto što je njegovim internim mehanizmima smisleno. Prilikom primenjivanja konkatenacije nad brojem i niskom, broj će biti konvertovan u nisku.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//zakomentarisati sve linije pa redom oslobadjati 
var conv = '5' + 3; //53
conv = 3 + '3'; //33
conv = 5 * null; //0
conv = '7' - 4; //3 
conv = !""; //true 
console.log(conv);
console.log(typeof conv);
\end{lstlisting}
Kako bismo proverili da li su dve vrednosti jednake koristimo $"$==$"$, ali da bismo bili precizniji i proverili da li su vrednosti koje poredimo i istog tipa moramo koristiti $"$===$"$. Važnost ovog koncepta se jasno vidi u narednom primeru:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(10 == '10'); //true
console.log(10 === '10'); //false
\end{lstlisting}

Vrlo često pri programiranju želećemo da dobijemo dužinu neke niske i potom pristupimo nekom pojedinačnom karakteru. To se lako postiže korišćenjem svojstva $length$ u vidu $niska.length$, a potom uz pomoć $charAt()$ pristupamo pojedinačnim karakterima niske.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//Pristup pojedinacnim karakterima niske
var niska = "Programiranje";
console.log("Svojstvo length daje duzinu niske", niska.length);
//prolaskom kroz petlju obilazimo sve karaktere niske redom
for(i=0; i<niska.length;i++){
    console.log(niska.charAt(i));	
}
//Obratiti paznju da brojanje niske krece od 0
console.log("5 karakter niske", niska.charAt(4));
\end{lstlisting}
Treba primetiti da brojanje karaktera u niski kreće od 0, pa tako 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
P R O G R A M I R A  N  J  E
0 1 2 3 4 5 6 7 8 9 10 11 12
\end{lstlisting}
Svi karakteri koje je moguće zapisati nalaze se u takozvanoj $ASCII$ tabeli i imaju svoje kodne cifre, te cifre nam nekada mogu biti od koristi. Njima se pristupa korišćenjem $charCodeAt()$. Da bismo uradili obrnuto, tj. izvršili konverziju broja u karakter koristimo $fromCharCode()$. Ako bismo želeli da uklonimo beline sa krajeva (i sa početka i sa kraja niske), koristimo $trim()$. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var voce = "  Ananas  "
console.log(voce.charCodeAt(2)); //A --> 65
console.log(String.fromCharCode(97)); //a
voce = voce.trim();
console.log(voce);     
\end{lstlisting}
Da bismo karaktere neke niske smanjili ili uvećali, koristimo metode $toUpperCase()$ ili $toLowerCase()$ u zavisnosti od toga šta želimo postići. Primetimo da se mogu primeniti i nad pojedinačnim karakterom.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(voce.toLowerCase()); //ananas
console.log(voce.toUpperCase()); //ANANAS
\end{lstlisting}
\subparagraph{Dodatne metode za rad sa niskama}
Metode nam omogućavaju da izvršimo neke akcije nad objektima. Postoji puno metoda za rad sa niskama, a u ovom delu biće navedene samo neke od njih. \\\\
U prethodnom delu već su predstavljene $charAt()$ i $charCodeAt()$. Prva nam daje (kaže se i vraća) karakter na poziciji koju pošaljemo kao argument, a druga nam vraća kodnu vrednost karaktera, koji se nalazi na poziciji prosleđenoj kao argument. Osim njih neki od istaknutih metoda su:
\begin{itemize}
    \item \textbf{concat()} - nadovezuje dve niske i vraća novu nisku ne menjajući stare,
    \item \textbf{includes()} - proverava da li niska sadrži određen karakter ili reč, kao drugi argument se šalje od koje pozicije početi sa traženjem,  
    \item \textbf{indexOf()} - vraća indeks prvog pojavljivanja niske koju šaljemo kao argument funkcije ili $-1$ ako ta niska nije pronađena (napomena: lastIndexOf() radi isto samo vraća poslednji), 
    \item \textbf{repeat()} - vraća string ponovljen onoliko puta koliko je navedeno u zagradi, 
    \item \textbf{replace()} - vraća novi string u kome je reč navedena kao prvi argument, zamenjena rečju navedenom kao drugi argument, 
    \item \textbf{search()} - pretražuje string za rečju koja je navedena kao argument i vraća poziciju od koje reč počinje u niski ili vraća $-1$ ako reč nije pronađena,  
    \item \textbf{slice()} - iz niske izdvaja deo niske počevši od indeksa naznačenog kao prvi argument, do indeksa naznačenog kao drugi, 
    \item \textbf{substr()} - iz niske izdvaja podnisku počevši od indeksa navedenog kao prvi argument u dužini navedenoj kao drugi argument.
\end{itemize}

Navedimo sada neke od primera primena ovih metoda.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var niska1 = "Danas je.";
var niska2 = "lep dan.";
var niska3 = niska1.concat(niska2);
console.log(niska3);
//hocemo da provermo da li niska3 sadrzi rec dan
console.log("Da li niska sadrzi rec dan", niska3.includes("dan"));
console.log("Da li niska sadrzi rec ana", niska3.includes("ana"));
console.log("Indeks prvog pojavljivanja reci dan", niska3.indexOf("dan"));
console.log("Indeks prvog pojavljivanja reci ana", niska3.indexOf("ana"));
console.log(niska1.repeat(4));
var niska4 = niska2.replace("dan", "covek");
console.log(niska4);
console.log("Na kom indeksu pocinje rec dan", niska3.search("dan"));
console.log("Na kom indeksu pocinje rec ana", niska3.search("ana"));
console.log(niska3.slice(1,4));
console.log(niska3);
console.log(niska3.substr(1,4));    
\end{lstlisting}


\subparagraph{Vežba}
Uraditi zadatke iz sekcije vezane za niske.

\subsubsection{Nizovi}
Nizovi predstavljaju kolekcije elemenata nekog tipa. U JavaScriptu, za razliku od većine drugih programskih jezika, dozvoljeno je da ti elementi budu različitih tipova. Novi niz kreiramo korišćenjem uglastih zagrada. Ako navedemo samo uglaste zagrade, onda se kreira prazan niz, odnosno, niz koji ne sadrži elemente. Elemente u nizu navodimo pisanjem između uglastih zagrada i odvajamo ih zarezima. Indeksiranje nizova počinje od 0. Indeksiranje nam je veoma važno kako bismo mogli da lako pristupimo vrednosti koju čuva neki element niza. Elementima niza pristupamo navođenjem naziva niza, a potom u uglastim zagradama indeksa kojem želimo da pristupimo. Opisani postupci predstavljeni su kroz primer u nastavku:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var niz = [];
var niz2 = [1,2,3,4,5];
var niz3 = ["niska1", "niska2"];
var niz4 = [1, "neki tekst", "!", 3.14];
niz4["kljuc"] = 5;
console.log(niz2[3]);
console.log(niz3[0]);
console.log(niz4[3]);
console.log(niz4);
\end{lstlisting}
Element niza može biti i neki drugi niz. Kao što se vidi u primeru iznad, osim što nizovi mogu čuvati različite tipove (niske, brojeve, razlomljene brojeve, karaktere), moguće je indeksiranje elemenata niza različitim tipovima. Ukoliko indeksi elemenata nisu eksplicitno navedeni, elementi niza su podrazumevano indeksirani celim brojevima počevši od 0. Kao posledica činjenice da nizovi mogu čuvati elemente različitih tipova, za element niza možemo postaviti i drugi niz, čime je moguće kreiranje matrica, pa tako:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//elementi niza mogu biti drugi nizovi
var niz1 = [niz2,0,1,4];
console.log("Niz 1:",niz1);
//kreiranje matrice
var matrica = [];
matrica[0] = [1,2];
matrica[1] = [3,4];
console.log(matrica[0][1]);
\end{lstlisting}
Da bismo obišli celu matricu, neophodno je da prođemo kroz sve njene elemente. Odnosno, da krećući se kroz elemente niza redom obiđemo svaki od elemenata. Kako bismo to učinili na najjednostavniji način, neophodno je da koristimo dvostruku $for$ petlju. Spoljašnja petlja bi se kretala po vrstama matrice, a unutrašnja po kolonama. Veličinu niza, kao i kod niski, uzimamo korišćenjem svojstva $length$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(matrica.length);
for(i = 0;i<matrica.length;i++){
    for(j = 0; j<matrica.length;j++){
         console.log("element u vrsti",i,"i koloni",j,"je:",matrica[i][j]);
    }
}
\end{lstlisting}
Treba obratiti pažnju da u primeru gore podrazumevamo da je matrica kvadratna (sa istim brojem vrsta i kolona). Kako bismo obišli matricu koja ima različit broj vrsta i kolona treba da obratimo pažnju na veličinu vrste i veličinu kolone. Čitaocu se ostavlja radi vežbe i boljeg razumevanja funkcionisanja matrica i nizova da isproba obilaske matrice za različit broj vrsta i kolona.\\\\
Da bismo nekom elementu niza promenili vrednost dovoljno je da ga nađemo po indeksu, a potom da naredbom dodele navedemo novu vrednost. Važno je istaći da ta nova vrednost ne mora biti istog tipa.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var brojevi = [1,2,3,4];
brojevi[3] = 6;
console.log(brojevi); //1,2,3,6
brojevi[3] = "Sest";
console.log(brojevi); //1,2,3,"Sest"
\end{lstlisting}

Elemente niza možemo postaviti eksplicitno bez obzira na to da li neke indekse izostavljamo, pa je tako moguće postaviti vrednosti $brojevi[5]$ i $brojevi[7]$, a potom ispisati sve elemente niza. Za one indekse koje smo preskočili $console.log$ će ispisati $empty$.

\begin{lstlisting}[backgroundcolor = \color{lightgray}]
brojevi[5] = 15;
brojevi[7] = 99;
console.log(brojevi); //[1,2,3,"Sest",empty,15,empty,99]
\end{lstlisting}

Nizovi i petlje se dosta dobro kombinuju, u smislu da sa petljama lako obilazimo elemente niza, kao što je i viđeno u prethodnim primerima. Kod $for$ petlje primetili smo da promenljiva $i$ dobija vrednost indeksa svakog od elemenata niza. Osim standardne $for$ petlje, u $JavaScript-u$ moguće je koristiti i poseban vid $for$ petlje, tzv. $for-in$ petlju. Ova petlja funkcioniše na isti način kao standardna $for$ petlja prolazeći kroz elemente redom, ali je njen zapis dosta kraći. Osim toga, $for-in$ petlja će proći samo kroz elemente koji postoje (preskočiće indekse u nizu koji ne čuvaju nikakvu vrednost!). Ovakvo ponašanje se najbolje oslikava kroz primer.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
for(i=0;i < brojevi.length; i++){
	console.log(brojevi[i]); 
}
for(i in brojevi){
	console.log(brojevi[i]);
}
\end{lstlisting}
Ispisom kroz konzolu, lako se vidi da je prva petlja dala $1$, $2$, $3$, $"$Sest$"$, $undefined$, $15$, $undefined$, $99$, a druga $for$ petlja $1$, $2$, $3$, $"$Sest$"$, $15$, $99$. 
 

\subparagraph{Neke metode za rad sa nizovima}

Pomenimo, pre svega, još jedan bitan metod za rad sa niskama. Metodom $split()$ od postojeće niske kreiramo niz. Argument koji prosleđujemo predstavlja po kom kriterijumu da se izvrši podela niske. Da bismo uradili obratno, odnosno, od niza kreirali nisku, koristimo metod $join()$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
//Metod za rad sa niskama koji od niske kreira niz: split 
var niska = "Danas je lep dan.";
var niz = niska.split(" ");
console.log(typeof niz);
console.log(niz);

//Metod koji od niza formira nisku: join
niz = ["danas", "je", "tmuran", "dan"];
niska = niz.join();
console.log(typeof niska);
console.log(niska);
\end{lstlisting}
Pomenimo još neke istaknute metode za rad sa nizovima:  
\begin{itemize}
    \item \textbf{concat()} - nadovezuje dva niza i vraća novi ne menjajući stare,
    \item \textbf{includes()} - proverava da li niz sadrži određeni element, kao argument se šalje  ono što se traži, ako postoji vraća $true$, inače, vraća $false$,  
    \item \textbf{push()} - dodaje novi element na kraj niza, 
    \item \textbf{pop()} - skida poslednji element sa kraja niza, 
    \item \textbf{reverse()} - vraća obrnut niz, 
    \item \textbf{slice()} - iz niza izdvaja deo počevši od indeksa naznačenog kao prvi argument, do indeksa naznačenog kao drugi i vraća novi niz, 
    \item \textbf{sort()} - sortira niz.
\end{itemize}
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var niz_brojeva = [1,2,3,4];
var novi = niz_brojeva.concat(niz);
console.log(novi);

console.log("Da li niz sadrzi broj 13?", niz.includes(13)); //false
niz.push(13);
console.log("Dodat je novi element na kraj niza",niz);
niz.pop()
console.log("Niz kada skinemo poslednji element",niz);
			
niz.reverse();
console.log("Obrnut niz",niz);

niz = niz.slice(1,3);
console.log(niz);
niz_brojeva.reverse();
console.log(niz_brojeva);
niz_brojeva.sort();
console.log(niz_brojeva);
\end{lstlisting}

\subparagraph{Vežba}
Uraditi sve zadatke iz sekcije Nizovi.

\subsubsection{Svojstva i objekti}

Ako bismo u naš niz dodali još jedan element:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
niz[4] = {svojstvo: 5 };
console.log(niz[4]);			
\end{lstlisting}
Primećujemo da smo u niz dodali nešto novo oblika ${naziv\_svojstva : vrednost }$. Takav konstrukt nazivamo objektom. Objekti su strukture podataka koje čine nizovi svojstava i njihovih vrednosti. Većina JavaScript vrednosti imaju neka svojstva, već smo se susreli sa svojstvom $length$ za nizove. U primeru navedenom gore imamo samo jedno svojstvo $svojstvo$. Pogledajmo nešto intuitivniji primer. U primeru kreiramo jednog studenta sa svim svojstvima koja su nam za jednog studenta interesantna:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var student = { ime : "Una",
prezime : "Stankovic",
datum_rodjenja : "13.10.1994.",
jmbg: 1310994715004,
broj_indeksa: "1095/2016",
nivo_studija: "m",
prosek: 9.75,
ocene: [8,9,10]};
console.log(student);
\end{lstlisting}
Ispisom objekta student u konzoli, možemo videti svojstva i sve vrednosti svojstava. Primetimo da vrednosti svojstava opet mogu biti različite vrednosti.\\
Zanima nas sad kako možemo pristupiti vrednostima svojstava i to je moguće učiniti na dva načina:
\begin{itemize}
	\item $"$tačka notacijom $"$- $nazivobjekta.svojstvo$, na primer $student.ime$
	\item $"$po indeksu$"$ - $nazivobjekta['svojstvo']$, na primer $student['ime']$
\end{itemize}
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(student);
console.log(student.ime);
console.log(student["ime"]);
\end{lstlisting}
Napomena: u slučaju da je svojstvo broj ili da sadrži razmake u nazivu ne može se koristiti tačka notacija.\\\\
Ako pokušamo da pristupimo vrednosti svojstva koje ne postoji dobijamo $undefined$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log(student.drzavljanstvo);
\end{lstlisting}

Svojstvu dodeljujemo vrednost uz pomoć naredbe dodele (operatora $=$). Ako bismo počeli od praznog objekta kako bismo mu dodali nova svojstva možemo koristiti samo tačka notaciju. JavaScript sam prepoznaje da ta svojstva ne postoje i dodaje ih. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var racunar = {};
console.log(racunar);
console.log(typeof racunar);
racunar.licni_racunar = "da";
racunar.os = 'windows';
racunar.marka = 'lenovo';
console.log(racunar);
\end{lstlisting}
Za uklanjanje svojstva iz objekta koristimo unarni operator $delete$.
Ako pokušamo da pristupimo vrednosti svojstva koje smo obrisali dobijamo $undefined$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
delete racunar.licni_racunar;
console.log(racunar.licni_racunar);
console.log(racunar);
\end{lstlisting}

Binarnim operatorom $in$ lako se proverava da li neki objekat sadrži neko svojstvo. U zavisnosti od toga da li svojstvo postoji ili ne vraćaju se $true$ ili $false$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
console.log("licni_racunar" in racunar); //false
console.log("os" in racunar); //true
\end{lstlisting}

Koncept \textbf{refereciranja objekata} je veoma važan. Naime, kod objekata moramo razlikovati da li imamo dve različite reference ka istom objektu ili dva objekta imaju ista svojstva. U prvom slučaju, kada imamo dve različite reference ka istom objektu, dve različite promenljive pokazuju na isti memorijski prostor, a svaka promena izvedena nad objektom preko jedne promenljive propagiraće se i na drugu. U drugom slučaju, kada dva objekta imaju ista svojstva, ali su ti objekti različiti, promene izvedene nad jednom promenljivom neće imati nikakvog uticaja na drugu. Kako bismo ovo bolje razumeli, najbolje da pogledamo naredni primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var student1 = {ime : "Janko",
	prezime: "Jovanovic",
	prosek: 9.5};
var student2 = student1;
var student3 = {ime : "Jovana",
	prezime : "Markovic",
	prosek : 8.5}
console.log(student1 === student2); //true
console.log(student2 === student3); //false
console.log(student3 === student2); //false
\end{lstlisting}
Vidimo da pri poređenju objekata dobijamo da su objekti $student1$ i $student2$ isti. Sada pogledajmo šta se dešava kada pokušamo da izvršimo neku promenu nad $student1$. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
student1.ime = "Ana";
console.log(student2.ime); //Ana
console.log(student3.ime); //Jovana
\end{lstlisting}
Obratiti pažnju da je u prvom $console.log$-u $student2$.

\subsubsection{Funkcije}
Funkcija je jedna od osnovnih konstrukcija jezika koja nam omogućava ponovno korišćenje koda. Omogućavaju nam, čak, i da ih koristimo iako ne razumemo detalje implementacije. Štaviše, već smo koristili neke od ugrađenih funkcija, kao što su prompt, alert, parseInt, itd.. Izdvajanjem koda u funkcije povećava se čitljivost koda i olakšava se njegovo održavanje. Osim toga, olakšava se ponovna upotrebljivost koda (engl. reusability). Naime, vrlo često će nam biti potrebno da ponovo iskoristimo neki kod, neku funkciju koja nam se javlja u više programa. Upravo zbog toga, u $JavaScript$-u , kao i u mnogim drugim programskim jezicima, postoje ugrađene funkcije, kao i dodatne biblioteke sa funkcijama koje je moguće koristiti kako bi se olakšao rad. Moguće je čak i pisanje sopstvenih biblioteka.    
\\
Osnovno uputstvo za pisanje funkcija se sastoji iz nekoliko bazičnih koraka:
\begin{itemize}
\item Uočiti logičke celine
\item Uočiti neophodne parametre i povratnu vrednost 
\item Dati ime koje odgovara implementaciji
\item Implementirati funkciju
\end{itemize}

Funkcija se odlikuje svojom deklaracijom i definicijom.
Deklaracija (ili prototip) funkcije ima opšti oblik:\\
$function\ ime\_funkcije(niz\_deklaracija\_parametara);$\\\\
Definicija funkcije ima oblik:
\begin{verbatim}
function ime_funkcije(niz_deklaracija_parametara) {
   deklaracije
   naredbe
}
\end{verbatim}
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function sabiranje(a,b){

}
\end{lstlisting}

\subparagraph{Parametri i argumenti funkcije}
Funkcija može imati parametre koje obrađuje i oni se navode u
okviru definicije, iza imena funkcije i izmedu zagrada.
Termini parametar funkcije i argument funkcije se ponekad
koriste kao sinonimi. Objasnimo kroz primer razliku između ovih pojmova. Naime,  $n$ je parametar funkcije $kvadrat(n);$, a $5$ i $9$ su
njeni argumenti u pozivima $kvadrat(5)$ i $kvadrat(9)$.\\\\
Parametri funkcije mogu se u telu funkcije koristiti kao lokalne
promenljive\footnote{Lokalne promenljive su vidljive samo unutar tela te funkcije.} te funkcije, a koje imaju početnu vrednost
određenu vrednostima argumenata u pozivu funkcije.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function sabiranje(a,b){
	var zbir = a + b;
}

var a = 5;
var b = 7;
sabiranje(5,7);
\end{lstlisting}

\subparagraph{Povratna vrednost funkcije}
\textbf{Povratna vrednost} funkcije predstavlja glavni rezultat rada te funkcije.Funkcija rezultat vraća naredbom $return\ r;$ gde je $r$ izraz ili promenljiva. Nakon završetka svih naredbi unutar funkcije ili dolaskom do naredbe $return$ izvršavanje se nastavlja od mesta odakle je funkcija pozvana.
Naredba $return\ r;$ ne samo da vraća vrednost $r$ kao rezultat
rada funkcije, nego i prekida njeno izvršavanje. Funkcija može vraćati i rezultat izračunavanja nekog izraza, kao funkcija $sabiranje2$ u primeru dole. Vrednost koju funkcija vrati možemo smestiti u neku promenljivu kako bismo mogli sa njom na dalje da radimo. Funkcije mogu pozivati druge funkcije, a funkcija može pozivati i samu sebe. Više o slučaju kada funkcija poziva samu sebe biće u sekciji o rekurzivnim funkcijama.\\\\

\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function sabiranje(a,b){
	var zbir = a + b;
	return zbir;
}

function sabiranje2(a,b){
	return a + b;
}

var a = 5;
var b = 7;
sabiranje(5,7);
var c = sabiranje2(a,b);
\end{lstlisting}

Kao što vidimo kada pozivamo funkciju koristimo naziv funkcije, a potom navodimo listu argumenata. Funkcija može primati nula ili više argumenata. U slučaju, da funkcija nema argumente pozivamo je kao $ime\_funkcije()$. Funkcija bez argumenata će se izvršiti i vratiti povratnu vrednost. Ako funkcija ima jedan ili više argumenata, njih navodimo između zagrada, odvojene zarezima. Bitno je naglasiti da nazivi parametara pri definisanju funkcije i argumenata pri njenom pozivanju ne moraju biti isti, ali promenljive korišćene u telu funkcije i nazivi parametara moraju biti isti! To je posledica toga što promenljive navedene u definiciji dobijaju vrednosti argumenata, koje se kasnije koriste u telu funkcije, one su poput najave da će se na tom mestu očekivati neke vrednosti koje kasnije treba koristiti na tačno određen način (što je definisano u telu funkcije).  

\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function sabiranje(a,b){
	var zbir = a + b;
	return zbir;
}

function sabiranje2(a,b){
	return a + b;
}
//funkcije bez argumenata
function pozdrav(){
	console.log("Hello World!");
	return;
}

function dodatak(){
	var broj = Math.random()*100;
	return broj;
}

var a = 5;
var b = 7;
sabiranje(5,7); //nema ispisa nikakvog
var c = sabiranje2(a,b); 
console.log(c);
pozdrav(); //"Hello World!"
console.log(dodatak());
\end{lstlisting}
Primetimo da iako funkcija ne vraća nikakvu konkretnu vrednost na kraju funkcije se nalazi $return;$.
Napomena: Funkcija $Math.random()$ korišćena u primeru je funkcija iz biblioteke $Math$ i vraća nasumični broj između $0$ i $1$. \\\\

Osim navedenog načina moguće je funkciju dodeliti promenljivoj. Obratiti pažnju da nakon poslednje vitičaste zagrade mora stajati tačka-zarez. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var stepenovanje = function(osnova, eksponent){
		var rez = 1;
        for(i = 0; i < eksponent; i++){
        	rez *= osnova;
        }
        return rez;
	};
console.log(stepenovanje(2,3));
\end{lstlisting}


\subparagraph{Vežba}
Uraditi sve zadatke iz uvodne sekcije koristeći funkcije. Uraditi zadatke iz sekcije funkcije.

\subparagraph{Anonimne funkcije}
Anonimne funkcije su funkcije koje nemaju naziv. Anonimne funkcije koristimo kada želimo da se neka funkcija izvrši jednom. Vrednost anonimne funkcije ne možemo koristiti ukoliko je ne smestimo u neku promenljivu ili nije deo neke druge funkcije o čemu će biti više reči kasnije. Definisanjem funkcije dodelom promenljivoj kreiramo anonimnu funkciju sa desne strane naredbe dodele. Pogledajmo još jedan primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var anonimna = function(){
	console.log("Dosli ste do anonimne funkcije.");
	return;
	};
anonimna();
\end{lstlisting}
%Anonimne funkcije imaju i svoj skraćeni zapis u vidu \textbf{lambda funkcija} oblika:
%\begin{verbatim}
%(lista parametara) => telo funkcije
%\end{verbatim}
%Zagrade oko parametara su neophodne ukoliko je broj parametara veći od 1. Ukoliko funkcija nema %parametara onda su potrebne samo $()$. Ukoliko funkcija ima samo jednu naredbu i ta naredba je $%$return$ sa povratnom vrednošću, onda nam ni reč $return$ nije neophodna. Pogledajmo primere:
%\begin{lstlisting}[backgroundcolor = \color{lightgray}]
%x => { return x*x; }
%console.log(x);
%x => x*x;
%\end{lstlisting}

\subparagraph{Broj argumenata funkcije}
Lako se uočava da pri pozivu funkcije možemo funkciji poslati više argumenata nego što ona zahteva. U $JavaScriptu$ je to dozvoljeno ponašanje, iako u većini drugih programskih jezika nije. Ako bismo poslali veći broj argumenata nego što funkcija zahteva, ona bi višak argumenata ignorisala. U slučaju da je poslato manje argumenata nego što funkcija zahteva, za oni parametri za koje argumenti nisu poslati postavljaju se na $undefined$. Zaključak, $JavaScript$ ne proverava ni broj ni tip poslatih argumenata.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 5;
var b = 7;
//fija: sabiranje2(a,b);
console.log(sabiranje2(a,b,4,2,1));
\end{lstlisting}
Pogledajmo još jedan primer.  Funkcija $argumenti()$ prima $2$ argumenta, posmatrajmo šta se dešava u različitim slučajevima:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function argumenti(prvi, drugi){
	console.log(prvi);
	console.log(drugi);
    return;
}
argumenti("Prvi","Drugi"); //prvi drugi
argumenti("Prvi"); //prvi undefined
argumenti(); //undefined undefined
argumenti("Prvi","Drugi","Treci"); //prvi drugi	
\end{lstlisting}

$JavaScript$ funkcije imaju ugrađeni objekat $arguments$. Ovaj objekat možemo koristiti da na jednostavan način proverimo koji je broj argumenata poslat.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
 function prosek(){
	var suma = 0;
	console.log("Broj argumenataje:",arguments.length);
	for(i=0;i<arguments.length;i++){
    suma += arguments[i];
	console.log(arguments[i]);
    }
	var prosek = suma / arguments.length;
    console.log(suma);
	return prosek;
    }
	var p = prosek(9,10,10,6,8);
    console.log("Prosek ocena je:",p);	
\end{lstlisting}
Na ovaj način možemo pristupiti argumentima koje bismo inače ignorisali.
U jeziku $JavaScript$ argumenti se prenose po vrednosti. To znači da se njihova originalna vrednost ne menja. Sa druge strane, objekti se prenose po referenci, što znači da se njihova originalna vrednost menja.\\\\
Nekada nam nije odmah poznato koliko parametara će funkcija imati. $JavaScript$ nam omogućava da funkcije mogu imati i proizvoljan broj parametara. Da bismo napisali ovakvu funkciju koristimo sledeću notaciju:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
 function nova(...parametri){
	for(parametar of parametri){
		//uradi nesto sa parametrima	
	} 
 }
\end{lstlisting}
Pogledajmo i na primeru:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function lista_za_kupovinu(...parametri){
	for(parametar of parametri){
    	console.log(parametar);    
    } 
}
console.log("Lista za kupovinu");
lista_za_kupovinu("mleko","hleb","lazanje","torta");
\end{lstlisting}
Primetimo da smo koristili $for-of$ petlju za kretanje kroz listu parametara. Ova petlja nam služi za kretanje kroz nizove, karaktere niski, mape, skupove, itd. Napomena: ranije smo videli $for-in$
petlju, ta petlja se najčešće koristi za iteraciju kroz svojstva objekata ili indekse.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var ucenik = { ime : "Ana",
	indeks: "1083/2016",
    prosek: 9.41};
for(kljuc in ucenik){
	console.log(`${kljuc} --> ${ucenik[kljuc]}`);
}  

var str = "Neki tekst";
for(indeks in str){
	console.log(`Indeks ${str[indeks]}:${indeks}`);
}
\end{lstlisting}

\subparagraph{Periodično izvršavanje funkcija}
Nekada funkcije želimo da izvršavamo periodično, odnosno, želimo da se kod unutar funkcije izvršava nakon određenog vremenskog intervala. Za ovakvo izvršavanje funkcija koristimo funkcije $setTimeout()$ i $setInterval()$.\\\\
Funkcija $setTimeout()$ izvršava naredbe nakon vremenskog intervala zadatog u milisekundama ( 1000ms = 1s). Prvi argument je funkcija koja se izvršava nakon broja milisekundi navedenih kao drugi argument funkcije. Funkcija koja se prosleđuje kao argument funkcije $setTimeout()$ može biti i anonimna funkcija. U tom slučaju nju direktno pišemo u okviru zagrada funkcije. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function objava(){
	alert("Obavesteni ste!");
}
setTimeout(objava,4000);
//anonimna fija je prvi argument
setTimeout(function(){
	alert("Obavesteni ste iz anonimne funkcije!");
},5000);
\end{lstlisting}
Funkciju $setTimeout()$ možemo koristiti i za periodično izvršavanje funkcije tako što ćemo je pozvati unutar neke funkcije $f()$ koju želimo da izvršavamo više puta, a kao prvi argument šaljemo naziv te funkcije iz koje se poziva. Napomena: Neophodno je posebno pozvati funkciju $f()$ prvi put.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
 //Funkciju setTimeout mozemo koristiti i za periodicno izvrsavanje
function objava2(){
	alert("Obavestenje u intervalu!");
    setTimeout(objava2,1000);
	}
objava2();
\end{lstlisting}
Povratna vrednost funkcije $setTimeout()$ je identifikator tajmera koji je pokrenut, za prekidanje tajmera koristimo funkciju $clearTimeout()$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var tajmer = setTimeout(function(){
	alert("Ovaj tekst se nece ispisati");
	}, 2000);
clearTimeout(tajmer);
\end{lstlisting}
Osim funkcije $setTimeout()$ za periodično izvršavanje funkcija možemo koristiti funkciju $setInterval()$. Ova funkcija prima iste argumente kao i $setTimeout()$, samo što u njenom slučaju broj milisekundi predstavlja broj nakon kog će se ponovo izvršiti funkcija navedena kao prvi argument.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
setInterval(function(){
	alert("Ova funkcija ce se izvrsavati svake sekunde.")
	}, 1000);
\end{lstlisting}
Kao i kod $setTimeout()$ povratna vrednost funkcije $setInterval()$ je tajmer. Kako bismo prekinuli tajmer moramo pozvati funkciju $clearInterval()$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var tajmer = setInterval(function(){
	alert("Ovo ce se izvrsiti samo jednom");
},1000);
//Nakon 1.5 sekunde ce se pozvati prekidanje setInterval()
setTimeout(function(){
	clearInterval(tajmer);
},1500);
\end{lstlisting}

\subsubsection{Objekat Math}
Primetili smo da smo pri pisanju funkcija za rad sa brojevima pisali neke funkcije koje bi trebalo da se dosta često koriste pri matematičkim izračunavanjima. Osim toga, pominjali smo i da se funkcije koriste kako bi nam omogućile da neke postupke koji su nam često potrebni napišemo samo jednom, a potom upotrebljavamo kad god nam je to neophodno. $JavaScript$ u okviru objekta \textbf{Math} nudi definisane matematičke funkcije i konstante. Neke od njih su:
\begin{itemize}
	\item \textbf{Math.random()} - generiše pseudoslučajne brojeve iz intervala 0,1, 
	\item \textbf{Math.round(x)} - zaokružuje broj $x$ na najbliži ceo broj,  
	\item \textbf{Math.sqrt(x)} - računa koren broja $x$, 
	\item \textbf{Math.pow(x,y)} - računa $y$-ti stepen broja $x$,  
	\item \textbf{Math.min(x,y,z,...)} - računa minimum brojeva navedenih kao argumente,
	\item \textbf{Math.max(x,y,z,...)} - računa maksimum brojeva navedenih kao argumente i
	\item \textbf{Math.PI} - konstanta $\pi$.
\end{itemize} 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var a = 9;
var b = 3;
console.log("Koren ",a,"je", Math.sqrt(a));
console.log(a,"na",b,'je',Math.pow(a,b));
console.log("Minimum brojeva",a,",",b,", 
	120 i 2 je",Math.min(a,b,120,2));
console.log("Maksimum brojeva",a,",",b,",
	120 i 2 je",Math.min(a,b,120,2));
console.log("Broj ",a,"puta konstanta pi je", 
	a*Math.PI,"\nKada se dobijeni broj podeli sa 14 i 
	zaokruzi dobija se:",Math.round((Math.PI*a)/14));
\end{lstlisting}


\subparagraph{Vežba}
Modifikovati prethodno urađene primere tako da se koriste funkcije objekta $Math$.

\subsubsection{Doseg promenljivih}
Doseg (engl. scope) važenja promenljive označava u kojim sve delovima koda je neku promenljivu moguće $"$videti$"$, odnosno, pristupati joj, menjati je i koristiti. Dobro razumevanje i poznavanje dosega važenja promenljive nam je veoma bitno pri programiranju. Nekada se može desiti da pokušavamo da pristupimo promenljivoj u nekom delu koda u kome ona nije vidljiva ili da, još gore, nesvesno promenimo vrednost neke promenljive, što kasnije može imati posledice po izvršavanje ostatka programa.\\\\
Mesto gde uvodimo promenljivu utiče na njen doseg. Promenljive kreirane van svih blokova koda i funkcija imaju \textbf{globalni doseg}. Promenljive koje predstavljaju argumente funkcije, kao i one koje kreiramo unutar funkcija imaju doseg te funkcije u kojoj se nalaze.
Do sada smo promenljive kreirali koristeći isključivo ključnu reč $var$. Postoje još dve ključne reči kojima kreiramo promenljive to su $let$ i $const$. Promenljive kreirane ključnom rečju $let$ i $const$ imaju \textbf{lokalni doseg}. To znači da su one vidljive samo unutar bloka u kom su deklarisane. Promenljive uvedene ključnom rečju $var$ za funkciju važe na nivou cele funkcije. Pogledajmo naredni primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function vidljivost(x){
	console.log(x);
    var x = 5;
	console.log(x);
    if(x == 5){
	//promenljive mozemo kreirati koristeci let
	//let promenljive imaju lokalni doseg
	let n = 7;
	console.log("n iz if-a:",n);
	}
    else{
	console.log("n iz else-a:",n);   
    }
    return x;
}
var x = 10;
vidljivost(x);
console.log(x);
\end{lstlisting}
Iz primera se vidi da je promenljiva $x$ globalna. U funkciji $vidljivost(x)$ najpre ispisujemo vrednost promenljive $x$, i dobijamo $10$, što je ono što smo i prosledili. Potom unutar funkcije menjamo vrednost promenljive $x$ na $5$. Nakon toga kreiramo promenljivu n, koja nije vidljiva u $else$ grani (probati ovo tako što ćete zakomentarisati liniju $var x = 5;$. Nakon poziva funkcije ponovo ispisujemo vrednost promenljive $x$ i vidimo da ništa nije promenjeno. Posmatrajmo još jedan primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function zbir(){
	return c+d;
}

var c = 7; //zakomentarisati
var d = 8; //zakomentarisati
console.log(zbir());
var a = 5;
var b = 7;
console.log(zbir(a,b));
\end{lstlisting}


Primetimo da funkcija uvek radi za promenljive $c$ i $d$ zato što su globalno definisane, pa funkcija može da nađe njihove vrednosti. U slučaju da su $c$ i $d$ nedefinisani izbacuje se greška.\\\\
Obratite pažnju i na to šta se dešava sa $let$, kada pokušamo da mu promenimo vrednost. Zameniti $let$ sa $var$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function vidljivost_let(){
	let x = 5;
	if(true){
		let x = 7;
		console.log(x); //7
	} 
	console.log(x); //5
}
vidljivost_let();
\end{lstlisting}

Osim promenljivih, funkcije isto mogu biti deklarisane globalno i lokalno. Globalno deklarisane funkcije su vidljive i mogu se pozivati na nivou celog programa, a lokalno deklarisane funkcije samo unutar one funkcije (i njenih drugih podfunkcija) u kojoj je deklarisana. \textbf{Izvlačenje deklaracija} (engl. hoisting) je pojam koji se odnosi na to da $JavaScript$ izvlači deklaracije funkcija i promenljivih tokom faze kompajliranja što nam omogućava da vršimo pozive funkcija ili promenljivih i pre njihovog definisanja (obratiti pažnju da se izvlače deklaracije, ali ne i definicije!). Navedeni koncepti se oslikavaju kroz sledeće primere. Najpre, vidljivost funkcija:

\begin{lstlisting}[backgroundcolor = \color{lightgray}]

function globalna(){
	console.log("Ova funkcija je vidljiva i moze se 
	pozvati na nivou celog programa.");
}
function globalna_2(){
	lokalna(1); //poziv pre definicije
	function lokalna(n){
		console.log("Poziv",n, "iz lokalne:");
		globalna();
	}
	function lokalna2(){
		console.log("Poziv iz druge lokalne:");
		lokalna(2);
	}
    lokalna(3); //poziv nakon definicije   
    lokalna2();
}

globalna();
globalna_2();
lokalna(4);
lokalna2();
\end{lstlisting}
Potom, izvlačenje deklaracija:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
ispisi(s); //s is not declared
ispisi(parametar); //undefined
var parametar;
function ispisi(p){
	console.log("Vrednost parametra je:",p);
    return;
}
parametar = 10; 
ispisi(parametar);
\end{lstlisting}

\subsubsection{Rekurzivne funkcije}
Programski jezik $JavaScript$ podržava rekurzivne funkcije. Rekurzivne funkcije su one funkcije koje pozivaju same sebe. Uvek mora postojati neki uslov izlaska iz rekurzije. Najčešći primer koji se posmatra pri učenju ovih funkcija je \textit{Fibonačijev niz}.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
function fib(n){
	if(n == 0 || n == 1){
		return 1;	
	}
	return fib(n-1) + fib(n-2);
}

var a = 5;
console.log("a-ti Fibonacijev broj", fib(a));
\end{lstlisting}
Da bismo dobili naredni element potrebna su nam prethodna 2. Zbog toga, pozivamo funkciju za prethodna 2 broja. Uslov zaustavljanja je kada dođemo do $1$ ili do $0$.

\newpage
\subsection{DOM}
Rečeno je da je $JavaScript$ služi za davanje interaktivnosti stranici, međutim, do sad smo sve ispisivali u konzoli sa malo interakcije sa stranicom. Da bismo mogli da dodamo interaktivnost sa postojećim elementima stranice (ili da kreiramo nove) moramo najpre naučiti kako da tim elementima pristupimo. Za svaku web stranicu pregledač formira nešto što nazivamo \textbf{DOM}\footnote{engl. Document Object Model}. DOM je drvolika struktura čiji su elementi $HTML$ elementi (tagovi) i njihovi sadržaji(unutar tagova). $DOM$ čuva hijerarhijsku strukturu u smislu da je neki element, koji je u $HTML$-u bio roditeljski element nekog drugog elementa, i u $DOM$-u roditeljski element. Elementi koji su hijerarhijski $"$ispod$"$ nekog elementa nazivamo decom ili, ako je u pitanju jedan element, detetom (engl. child). Koren $DOM$ stabla je objekat $window$ koji predstavlja prozor pregledača. Elementi napisani u $HTML$-u odgovaraju čvorovima podstabla čiji je koren objekat $document$, jedan od sinova objekta $window$. Pogledajmo sliku:
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/structure.png}
\end{center}
\caption{Prikaz DOM stabla počevši od window objekta.}
\label{fig:domwin}
\end{figure}
\subparagraph{Vežba}  Izabrati sajt i kreirati strukturu $DOM$ stabla. Kao na primeru:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
<div>
 <h1>Ovo je naslov</h1>
 <h2>Ovo je podnaslov</h2>
</div>
\end{lstlisting} 	 
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/dom.png}
\end{center}
\caption{Prikaz primera DOM stabla.}
\label{fig:dom}
\end{figure}	  
\subsubsection{Osnove}
Kao što je ranije rečeno $JavaScript$ je skript jezik čija je osnovna uloga na Veb-u programiranje korisničkog interfejsa. Korišćenje jezika Javascript omogućava interakciju sa DOM stablom,
njegovo menjanje i obilaženje. Sve izmene napravljene nad čvorovima DOM stabla biće
vidljive na stranici u okviru elemenata čiji su odgovarajući čvorovi DOM-a menjani.
Naglasimo još jednom da programi napisani jezikom $JavaScript$ se izvršavaju na klijentskoj mašini (iako postoje i upotrebe na serveru).\\\\
Dohvatanje $DOM$ elemenata vrši se funkcijama definisanim u interfejsu $document$. Neke od najvažnijih navedene su u nastavku:
\begin{itemize}
\item \textbf{document.getElementsByTagName()} - dohvatanje elemenata čiji je naziv etikete (tag-a) prosleđen kao argument funkcije. Funkcija vraća niz objekata(čvorova stabla) koji odgovaraju pronađenim elementima. Niz je, kao i obično, indeksiran počevši od 0.
\item \textbf{document.getElementById()} - dohvatanje elementa čiji je $id$ prosleđen kao argument.
\item \textbf{document.getElementsByClassName()} - dohvatanje elemenata čiji je naziv klase prosleđen kao argument funkcije. Funkcija vraća niz objekata(čvorova stabla) koji odgovaraju pronađenim elementima. Niz je, kao i obično, indeksiran počevši od 0.
\item \textbf{document.getElementsByName()} -dohvatanje elemenata čija je vrednost atributa $name$  prosleđena kao argument funkcije. Funkcija vraća niz objekata(čvorova stabla) koji odgovaraju pronađenim elementima. Niz je, kao i obično, indeksiran počevši od 0.
\item \textbf{document.querySelector()} - dohvatanje elemenata CSS selektorom navedenim kao argument funkcije. Ukoliko ih je više, vraća samo prvi. 
\item \textbf{document.querySelectorAll()} - isto kao ponaša se isto kao $querySelector()$, osim što vraća niz svih objekata koji odgovaraju postavljenom kriterijumu. Niz je, kao i obično, indeksiran počevši od 0.
\end{itemize}
\begin{lstlisting}[backgroundcolor = \color{lightgray}, mathescape=true]
HTML:
<p class='pasus'>Neki pasus</p> 
<h1> Naslov nakon prvog pasusa</h1>
<div id='omotac'>
	<p class='pasus' id='pasus1'>Prvi pasus</p> 
	<p class='pasus' id='pasus2'>Drugi pasus</p>
	<p class='pasus' id='pasus3'>Treci pasus</p>
</div>

JS:
var omotac_element = document.getElementById("omotac");
var svi_pasusi = document.getElementsByTagName('p');
var pasusi_u_omotacu = document.querySelectorAll('#omotac .pasus'); // 
var prvi_pasus = document.querySelector('#omotac .pasus');
var drugi_pasus = document.querySelector('p:nth-child(2)');
var treci_pasus = pasusi_u_omotacu[2];
\end{lstlisting} 	 
Treba obratiti pažnju da se nazivi tagova navode između navodnika. Osim njih, uslove navodimo između navodnika. Primetimo da se uslovi mogu postavljati korišćenjem istih oznaka kao u $CSS$-u, pa tako uslov $'\#omotac\ .pasus'$ tumači se kao: $"$u elementu sa $id$-jem $omotac$ pronađi sve elemente koji pripadaju klasi pasus. $"$
Svojstvima dohvaćenog elementa pristupa se uz pomoć tzv. \textbf{tačka notacije}, što znači da nakon naziva promenljive, navodimo tačku, a potom ime svojstva. Sadržaj unutar etiketa $HTML$ elementa nalazi se u svojstvu $innerHTML$ objekta koji odgovara dohvaćenom elementu. Sadržaj ima tip niske.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<p id='pasusneki'>Neki<a href=''>link</a> pasus</p>

JS:
var sadrzaj = document.getElementById('pasusneki').innerHTML;
console.log(sadrzaj);
\end{lstlisting} 	 
Da bismo pristupili tekstualnom sadržaju nekog elementa koristimo svojstvo $textContent$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<p id='pasusneki'>Neki <a href=''>link</a> pasus</p>

JS:
var sadrzaj = document.getElementById('pasusneki').textContent;
console.log(sadrzaj);
\end{lstlisting}

Razlika između ova dva pristupa je što ćemo u prvom slučaju dobiti sav sadržaj unutar $<p>$ etiketa. U drugom slučaju, dobićemo samo tekstualni sadržaj kako je i prikazan na stranici. \\\\
Kada koristimo metode koje vraćaju više od jednog elementa, na primer $getElementsByTagName$, kako bismo saznali koliko je takvih elemenata možemo koristiti svojstvo $length$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var broj_elemenata = svi_pasusi.length;
console.log(broj_elemenata);
\end{lstlisting}
Kako bismo pristupili pojedinačnom elementu koristimo notaciju kao kod nizova (pošto metod zapravo i vraća niz elemenata).
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var pasus = svi_pasusi[0];
console.log(pasus);
var poslednji = svi_pasusi[broj_elemenata-1].textContent;
console.log(poslednji);
\end{lstlisting}

%Za pristupanje vrednostima $input$ elementa koristi se svojstvo $value$.
%\begin{lstlisting}[backgroundcolor = \color{lightgray}]
%HTML:
%<input type='text' id='ime'>

%JS:
%var input_polje = document.getElementById('ime');
%var vrednost_polja = input_polje.value;
%console.log(vrednost_polja);
%\end{lstlisting} 	 
CSS svojstvima elementa pristupa se pomoću svojstva $style$. Ovo svojstvo nam dozvoljava da eksplicitno zadajemo, menjamo i očitavamo stilove. Objekat koji odgovara
svojstvu $style$ sadrži samo eksplicitno zadate CSS vrednosti, ne i one koje nisu
navedene CSS-om a koje je pregledač samostalno izračunao. Vrednosti CSS svojstva se
pristupa preko njenog naziva, ukoliko naziv sadrži crticu za pristup svojstvu se koristi
naziv u kome crtica ne postoji, ali je prvo slovo posle crtice u originalnom zapisu veliko
(npr. $background\-color  \rightarrow backgroundColor$). Izračunate CSS vrednosti dobijaju se
funkcijom $getComputedStyle$ iz interfejsa $windows$, element čija se izračunata svojstva
traže se prosleđuje kao argument funkcije. Novu vrednost nekog svojstva postavljamo uz pomoć $element.style.osobina = vrednost$. Možemo na ovakav način dodavati i nove klase elementima, koristeći svojstvo $className$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var stil_pasusa = pasus.style;
console.log(stil_pasusa);
var izracunati_stil = window.getComputedStyle(pasus);
console.log(izracunati_stil.color);
stil_pasusa.backgroundColor = 'gray';
document.querySelector('#pasus1').style.fontSize = '12px';
document.querySelector('#pasus2').className = 'doterani_pasus';
\end{lstlisting} 	

Kada dohvatimo neki $HTML$ element, moguće je kretanjem kroz $DOM$ stablo doći i do ostalih elemenata prateći veze sa ostalim elementima. Roditeljskom elementu nekog elementa pristupa se preko svojstva $parentElement$, koja sadrži pokazivač na roditeljski element. Elementu na istom nivou $DOM$ stabla $brat$/$sestra$ elementa, koji u $HTML$ strukturi sledi nakon dohvaćenog pristupa se svojstvom $nextElementSibling$. Očekivano, njegovom prethodniku pristupa se sa $previousElementSibling$.\\\\
Na veoma sličan način možemo posmatrati i strukturu u odnosu na roditeljski element. Naime, prvom direktnom potomku roditeljskog elementa pristupa se sa $firstElementChild$, poslednjem sa $lastElementChild$. Svim direktnim potomcima se pristupa svojstvom $children$, koje sadrži niz objekata koji odgovaraju direktnim potomcima elementa. Pogledajmo kroz primer:
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var omotac = document.getElementById('omotac');
var prvi_pasus = omotac.firstElementChild;
var drugi_pasus = prvi_pasus.nextElementSibling;
var treci_pasus = drugi_pasus.parentElement.lastElementChild;
var naslov = omotac.previousElementSibling;
\end{lstlisting} 	
Na slici \ref{fig:dom3} se vidi grafički prikaz.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/parentchild2.png}
\end{center}
\caption{Prikaz odnosa između elemenata u DOM stablu.}
\label{fig:dom3}
\end{figure}
Na slici \ref{fig:dom2} se na primeru liste jasno vide odnosi između elemenata:
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/parentchild.png}
\end{center}
\caption{Prikaz odnosa između elemenata u DOM stablu.}
\label{fig:dom2}
\end{figure}	
Atributima dohvaćenih elemenata pristupa se funkcijom $getAttribute()$ kojoj se kao argument prosleđuje naziv atributa čija se vrednost traži. Postavljanje atributa elementima vrši se funkcijom $setAttribute()$ čiji je prvi argument naziv novog atributa, a drugi argument željena vrednost novog atributa.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<p id='pasus' title='Neki naslov'>Neki pasus</p>

JS:
var pasus = document.getElementById('pasus');
var title = pasus.getAttribute('title');
console.log(title);
pasus.setAttribute('class', 'klasa1');
\end{lstlisting}

\subparagraph{Vezba} Uraditi zadatke iz osnova DOM-a.

\subsubsection{Kreiranje elemenata}
Nekada ne želimo samo da menjamo postojeće elemente, već želimo i da kreiramo nove. Pravljenje novih elemenata vrši se funkcijom $createElement$ iz interfejsa $document$. Kao argument ova funkcija prima naziv etikete novog elementa (naziv etikete se navodi pod navodnicima). Element se vezuje u $DOM$ stablo kao poslednji sin nekog elementa funkcijom $appendChild$ čiji je argument element koji se u stablo dodaje. U slučaju da ne iskoristimo append child, element neće biti prikazan.

\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var omotac = document.getElementById('omotac');
var novi_pasus = document.createElement('p');
novi_pasus.innerHTML = "Treci pasus <a href=''>link</a>";
novi_pasus.setAttribute('id', 'pasus3');
//obavezno vezivanje novog pasusa kao poslednje dete omotaca
omotac.appendChild(novi_pasus);
\end{lstlisting}

Ukoliko zelimo da postavimo tekstualni sadržaj nad elementom, moramo napraviti novi tekstualni čvor sa $createTextNode$, a potom ga sa $appendChild$ dodati odgovarajućem elementu. Primetiti da sa $createTextNode$ takođe dodajemo tekst kao sa $innerHTML$. Razlika je u tome što će $innerHTML$ tumačiti etikete i prikazivati ih na odgovarajući način dok $createTextNode$ nece. Još jedna razlika koju možemo videti je ta da sa $innerHTML$ zamenjujemo celokupni sadržaj elementa novim sadržajem, dok sa $createTextNode$ dodajemo novi sadržaj na postojeći.

\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var cetvrti = document.createElement('p');
var sadrzaj = document.createTextNode("Cetvrti pasus <a href=''>link</a>");
cetvrti.appendChild(sadrzaj);
omotac.appendChild(cetvrti);

//createTextNode dodaje sadrzaj na postojeci
var pasus1 = document.getElementById('pasus1');
var sadrzaj = document.createTextNode('jos neki tekst unutar pasusa1');
pasus1.appendChild(sadrzaj);
//innerHTML zamenjuje sadrzaj u potpunosti
pasus1.innerHTML = "Tekst unutar pasusa1";
\end{lstlisting}

Dodavanjem novih elemenata sa $appendChild$, uvek dodajemo element kao poslednjeg naslednika u nizu elementa na koji vršimo $"$lepljenje$"$. Ako bismo želeli da dodamo novi element pre nekog drugog elementa koristimo $insertBefore()$. Ova funkcija prima dva argumenta. Prvi, novokreirani čvor, koji želimo da ubacimo pre drugog argumenta, koji predstavlja neki postojeći čvor. 
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
var pasus_jedan_ipo = document.createElement('p');
var pasus2 = document.getElementById('pasus2');
pasus_jedan_ipo.innerHTML = "pasus i po";
omotac.insertBefore(pasus_jedan_ipo, pasus2);
\end{lstlisting}

Ako želimo da obrišemo neki element koristimo $removeChild$. Sa $document.body$ pristupamo elementima koji se nalaze unutar $<body>$ etiketa.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<p id='obrisi'>Pasus koji zelimo da obrisemo</p>
JS:
var obrisi = document.getElementById('obrisi');
document.body.removeChild(obrisi);
\end{lstlisting}
\subparagraph{Vezba} Uraditi zadatke iz kreiranja elemenata DOM-a.

\subsubsection{Reagovanje na događaje}
Na način na koji smo do sada vršili interakciju sa stranicom još uvek nismo mogli da dobijemo pravu interaktivnost. Da bismo to postigli neophodno je da vršimo interakciju sa elementima DOM-a.
Svaka interakcija sa elementima DOM-a predstavlja događaj. Događaj predstavljaju različite interakcije korisnika sa stranicom kao što su: klik, prelazak miša, pritisak određenih tastera, itd..Prilikom pojave događaja moguće je reagovati i izvršiti određene naredbe. Da bi se pojava nekog događaja vezalo sa akcijom koju je potrebno preduzeti potrebno je prijaviti se, odnosno, „osluškivati“ pojavu nekog događaja.  Postoje dva načina da osluškujemo događaje. Prvi način za to je navođenje odgovarajućeg atributa elementa na kome se događaj očekuje. Takvi atributi obavezno imaju prefix $on$ nakon koga se nastavlja naziv događaja. Na primer, ako je naziv događaja $click$, atribut će imati naziv $onclick$. Vrednost atributa je naziv funkcije koju je potrebno izvršiti ukoliko se događaj desio. Obratiti pažnju da se naziv funkcije šalje sa zagradama i da naziv događaja ima prefiks $on$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<button onclick='prikaziObavestenje()'>Prikazi obavestenje</button>
JS:
function prikaziObavestenje(){
	alert("Obavestenje prikazano klikom na dugme.");
}
\end{lstlisting}
Neki od atributa koji postoje su: 
\begin{itemize}
\item \textbf{onclick} - definiše šta se događa kada korisnik klikne na površinu elementa 
\item \textbf{onchange} -  definiše šta se događa kada korisnik promeni vrednost npr. input elementa ili select elementa
\item \textbf{onfocus} - definiše šta se događa kada element dobije fokus (kada se korisnik pozicionira bilo mišem bilo tab tasterom na ovo polje)
\item \textbf{onblur} - definiše šta se događa kada element izgubi fokus
\item \textbf{onhover} - definiše šta se događa kada se pređe preko površine elementa 
\item \textbf{onkeyup} - definiše šta se događa kada korisnik pritisne taster na tastaturi (spust tastera) 
\item \textbf{onkeyup} - definiše šta se događa kada korisnik pusti pritisnuti taster na tastaturi 
\end{itemize}                        
 
Drugi način osluškivanja događaja je dodavanje „osluškivača“ ($listener$-a) u okviru
$JavaScript$ koda na element na kome se događaj očekuje, korišćenjem funkcije
$addEventListener()$. Ova funkcija prima dva argumenta. Prvi je naziv događaja čija se
pojava osluškuje, a drugi je naziv funkcije koja će se pozvati kada se događaj desi. Moguće je kao drugi argument navesti i anonimnu funkciju koja će biti definisana odmah na mestu argumenta. Obratiti pažnju da se naziv funkcije šalje bez ikakvih zagrada, a da naziv događaja nema prefiks $on$. Da bismo uopšte mogli da postavimo osluškivač događaja na neki element moramo ga najpre dohvatiti.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<button id='dugme1'>Dugme1</button>
<button id='dugme2'>Dugme2</button>
JS:
var dugme1 = document.getElementById('dugme1');
var dugme2 = document.getElementById('dugme2');
dugme1.addEventListener('click', prikaziObavestenje);
dugme2.addEventListener('mouseover', function(){
	alert("Obavestenje iz anonimne funkcije");
});
\end{lstlisting}

Neki od događaja na koje se može reagovati su:
\begin{itemize}
\item \textbf{click} – klik na element
\item \textbf{dblclick} – dupli klik na element
\item \textbf{focus}  – dovođenje elementa u fokus (klikom, dugmetom tab, programski...)
\item \textbf{blur} – promena fokusa sa fokusiranog elementa na drugi element
\item \textbf{mouseenter}  – ulaz kursora u okvir elementa
\item \textbf{mouseover} – pomeranje kursora preko elementa
\item \textbf{mouseleave} – izlaz kursora iz okvira elementa
\item \textbf{onload} – pri završenom učitavanju elementa (iscrtavanju i smeštanju u DOM)
\item \textbf{keypress}  – Pritisnuto je dugme na tastaturi dok je element u fokusu, objekat prosleđen kao argument funkciji za obradu događaja sadrži informacije o tome koje dugme je
pritisnuto
\end{itemize}

Svi navedeni događaji mogu biti korišćeni i kao atributi i kao argumenti funkcije. U prvom slučaju treba koristiti prefiks $on$. Za kompletnu listu ovih događaja konsultovati dodatnu literaturu.

\subparagraph{Vezba} Uraditi zadatke iz Reagovanje na događaje.

\subsubsection{Validacija formi}
Forme predstavljaju jedan od osnovnih vidova prikupljanja određenih podataka koje korisnik unosi. Da bi se informacije prikupile i sačuvale, podaci se šalju na server. Da ne bi došlo do toga da korisnik unosi besmislice veoma nam je važna validacija formi, odnosno, onoga što korisnik unosi.
Vrlo često želimo da analiziramo korisnički unos i pre nego što podatke pošaljemo na server. Time možemo da izbegnemo da se neispravni podaci šalju uopšte do servera, a potom da se vraća sa servera informacija da nešto nije u redu. Taj prvi nivo filtracije podataka vrši se upravo kroz $JavaScript$. Za pristupanje vrednostima input elemenata koristi se svojstvo $value$.
\begin{lstlisting}[backgroundcolor = \color{lightgray}]
HTML:
<input type='text' id='ime'>
<button id='dugme3' onclick='podatak()'>Konzola</button>
JS:
function podatak(){
	var vrednost_polja = input_polje.value;
	console.log(vrednost_polja);    
}
var input_polje = document.getElementById('ime');
var vrednost_polja = input_polje.value;
console.log(vrednost_polja);
\end{lstlisting}
Primetiti da ako uradimo $console.log(vrednost\_polja)$ van funkcije ne dobijamo ništa. To je posledica toga što u momentu kada se taj deo koda izvršava još uvek nije uneto ništa. Sa druge strane, ako bismo uneli neki tekst i potom klikom na dugme $Konzola$, pozvali funkciju $podatak()$, dobijamo ono što je uneto.
 
\newpage
\subsection{Zadaci sa casa}
Napomena: Rešenja zadataka nisu jedinstvena. Skoro svi zadaci se mogu uraditi na više načina. Za vežbu pokušati pronaći ili uraditi zadatke na više načina. 
\subsubsection{Uvodni primeri}

\begin{primer}
Napisati program koji za dva cela broja ispisuje najpre
njihove vrednosti, a zatim i njihov zbir, razliku, proizvod, ceo deo pri deljenju
prvog broja drugim brojem i ostatak pri deljenju prvog broja drugim brojem. 
\end{primer}


\begin{primer}
Napisati program koji za realne vrednosti dužina
stranica pravougaonika ispisuje njegov obim i površinu. Ispisati tražene vrednosti
zaokružene na dve decimale. 
\end{primer}

\begin{primer}
Napisati program koji za tri cela broja ispisuje
njihovu artimetičku sredinu zaokruženu na dve decimale.
\end{primer}

\begin{primer}
Napisati program koji za dva cela broja a i b dodeljuje
promenljivoj rezultat vrednost 1 ako važi uslov:
a) a i b su različiti brojevi
b) a i b su parni brojevi
c) a i b su pozitivni brojevi, ne veći od 100
U suprotnom, promenljivoj rezultat dodeliti vrednost 0. Ispisati vrednost promenljive
rezultat.
\end{primer}

\begin{primer}
Napisati program koji za dva cela broja ispisuje
njihov maksimum.
\end{primer}

\begin{primer}
Napisati program koji za dva cela broja ispisuje
njihov minimum.
\end{primer}

\begin{primer}
Napisati program koji za tri cela broja ispisuje zbir
pozitivnih.
\end{primer}

\begin{primer}
U prodavnici je organizovana akcija da svaki kupac dobije
najjeftiniji od tri artikla za jedan dinar. Napisati program koji za cene
tri artikla izračunava ukupnu cenu, kao i koliko dinara se uštedi zahvaljujući
popustu.
\end{primer}


\begin{primer}
Napisati program koji za redni broj dana u nedelji ispisuje
ime odgovarajućeg dana. U slučaju pogrešnog unosa ispisati odgovarajuću
poruku. Napomena: uraditi zadatak i korišćenjem case
\end{primer}

\begin{primer}
Napisati program koji za uneti karakter ispituje da li je
samoglasnik.
\end{primer}

\begin{primer}
Napisati program koji 5 puta ispisuje tekst $"$Mi volimo da
programiramo$"$.
\end{primer}

\begin{primer}
Napisati program koji preko prompta učitava ceo broj n i ispisuje n puta
tekst $"$Mi volimo da
programiramo$"$.
\end{primer}

\begin{primer}
Napisati program koji učitava pozitivan ceo broj n a potom
ispisuje sve cele brojeve od 0 do n.
\end{primer}

\begin{primer}
Napisati program koji učitava dva cela broja n i m ispisuje
sve cele brojeve iz intervala [n, m].\\
(a) Koristiti while petlju.\\
(b) Koristiti for petlju.\\
(c) Koristiti do-while petlju.\\
\end{primer}

\begin{primer}
Napisati program koji učitava ceo pozitivan broj i izračunava
njegov faktorijal. 
\end{primer}

\begin{primer}
Preko prompta unose se realan broj x i ceo pozitivan
broj n. Napisati program koji izračunava n-ti stepen broja x.
\end{primer}

\begin{primer}
Pravi delioci celog broja su svi delioci sem jedinice i samog
tog broja. Napisati program za ceo pozitivan broj x ispisuje sve njegove
prave delioce.
\end{primer}

\begin{primer}
Promptom se unosi ceo pozitivan broj n, a potom i n celih
brojeva. Izračunati i ispisati zbir onih brojeva koji su neparni i negativni.
\end{primer}

\begin{primer}
Program učitava realan broj x i ceo pozitivan broj n.
Napisati program koji izračunava i ispisuje sumu $S=x + 2*x^2 + 3*x^3 + ..$.
\end{primer}

\begin{primer}
Za unetu pozitivnu celobrojnu vrednost n napisati programe
koji ispisuju odgovarajuće brojeve. Pretpostaviti da je unos korektan.\\
(a) Napisati program koji za unetu pozitivnu celobrojnu vrednost n ispisuje
tablicu množenja.\\
(b) Napisati program koji za uneto n ispisuje sve brojeve od 1 do $n^2$ pri čemu se ispisuje po n brojeva u jednoj vrsti.\\
\end{primer}

\begin{primer}
Program učitava ceo pozitivan broj n, a potom n realnih
brojeva. Odrediti koliko puta je prilikom unosa došlo do promene znaka. Ispisati
dobijenu vrednost.
\end{primer}

\begin{primer}
Kreirati sajt prodavnice u kome svaki kupac određuje sam cenu artikla. U prodavnici se nalazi n artikala čije cene su realni brojevi. Na stranici treba da postoji naziv prodavnice, kao i spisak dostupnih artikala sa slikama, a potom da se uz pomoć prompta učita broj proizvoda koje korisnik želi da kupi. Nakon toga, unose se naziv proizvoda koji korisnik zeli da kupi i cena koju zeli. Za unet broj proizvoda treba u konzoli ispisati naziv proizvoda i ponuđenu cenu, odrediti ukupnu sumu i cenu najjeftinijeg artikla.
\end{primer}

\subsubsection{Niske}
\begin{primer}
Za unetu nisku proveriti da li sadrži broj i ispisati u konzoli. Napomena: koristiti $ASCII$ tabelu.
\end{primer}

\begin{primer}
Zameniti sva pojavljivanja slova $a$ u niski unetoj preko prompta slovom $b$. Na primer, $"$Danas je lep dan.$"$ sa $"$Dbnbs je lep dbn.$"$. Napomena: uraditi kreiranjem nove niske.
\end{primer}

\begin{primer}
Proveriti da li je reč uneta preko prompta palindrom. Palindromi su reči, rečenice koji se mogu čitati unapred i unazad i imaju isto značenje. Primeri za reči: Ana, bob, dovod, kapak, kajak, kuk, melem, neven, oko, pop, potop, ratar, teret. 
\end{primer}

\begin{primer}
Program učitava reč. Napisati
program koji proverava da li se od karaktera unete reči može napisati reč $Zima$.
\end{primer}

\begin{primer}
Program učitava ceo broj n, a zatim i n karaktera. Napisati
program koji proverava da li se od unetih karaktera može napisati reč $Zima$.
\end{primer}

\begin{primer}
Napisati program koji učitava karaktere sve do kraja ulaza (do unosa broja 0), a potom ispisuje broj velikih slova, broj malih slova, broj cifara, broj belina i zbir unetih cifara. 
\end{primer}

\begin{primer}
Napisati program koji za unetu nisku proverava da li sadrži reč $ima$.
\end{primer}

\begin{primer}
Kreirati sajt zdrave hrane. Sajt treba da sadrži naziv, logo, navigacioni bar (O nama, Proizvodi, Kontakt). 
\begin{itemize}
    \item Stranica o nama treba da sadrži: sliku, tekst o radnji, adresu i ostale relevantne informacije. 
    \item Kreirati potom stranicu sa proizvodima koja treba da sadrži najpre listu proizvoda (kategorije, pa potom po nekoliko proizvoda), a ispod toga treba da se nalaze neki od popularnih proizvoda sa slikama i cenama na 100 grama. 
    \item Stranica za kontakt treba da sadrži kontakt formu (Ime, email, prostor za poruku, itd.).  
\end{itemize}

Nakon toga koristeci prompt, alert i confirm za sajt sa zdravom hranom napraviti da se za 5 korisnika unese: ime, ocena sajta i predlog novog naziva zdrave hrane. Proveriti ispravnost unetog podatka, ako podatak nije pravilno unet ponuditi korisniku da ponovo unese podatak. Ako jeste, unosi se naredni. Unos ocena dodati na zbir. U konzoli ispisati predlog korisnika u formatu Ime : predlog. Na kraju, ispisati prosečnu ocenu sajta.
\end{primer}

\subsubsection{Nizovi}

\begin{primer}
Napisati program u kom za niz brojeva program ispisuje niz kvadriranih vrednosti.
\end{primer}

\begin{primer}
Napisati program u kom se unosi n, a potom i n elemenata niza. Nakon toga, na kraj niza se dodaje suma zadatih brojeva.
\end{primer}

\begin{primer}
Napisati program koji računa skalarni proizvod vektora a i b. Vektor $a=(a_1, a_2,...)$ i $b=(b_1, b_2,...)$, a skalarni proizvod $a*b= a_1 * b_1 + a_2 * b_2 + ... + a_n * b_n$. Najpre se unosi n, a potom po n vrednosti za vektore a i b. 
\end{primer}

\begin{primer}
Napisati program koji za dati niz ispisuje:\\
a) elemente na parnim pozicijama u nizu
b) parne elemente niza.
\end{primer}

\begin{primer}
Napisati program koji za učitani ceo broj, ispisuje broj
pojavljivanja svake od cifara u zapisu tog broja.
\end{primer}


\begin{primer}
Napisati program koji transformiše uneti niz tako što
kvadrira sve negativne elemente niza. 
\end{primer}

\begin{primer}
Sa standardnog ulaza se učitava dimenzija niza, elementi
niza i jedan ceo broj k. Napisati program koji štampa indekse elemenata koji su
deljivi sa k.
\end{primer}

\subsubsection{Objekti}
\begin{primer}
Kreirati objekat $"$Auto$"$. Objekat treba da sadrži: marku, godište, cenu.
Ispisati objekat na izlaz.
\end{primer}

\begin{primer}
Kreirati objekat $"$Film$"$, sa imenom filma, godinom izlaska, i ocenom na $IMDB$-u. Kreirati više takvih objekata i smestiti ih u niz (barem $5$). Na izlaz ispisati one filmove koji imaju ocenu preko $8$.  
\end{primer}

\begin{primer}
Kreirati objekat $"$Zaposleni$"$ za neku firmu. Objekat treba da sadrži: ime, prezime, datum rodjenja, identifikacioni broj, poziciju, platu, datum zaposlenja, da li je zaposlen za stalno, pol i spisak iznosa poslednjih $6$ plata.
\end{primer}

\begin{primer}
Za spisak zaposlenih u nekoj firmi (barem $5$), uraditi sledeće:
\begin{itemize}
	\item kreirati spisak zaposlenih: ime i prezime, visina plate, da li su stalno zaposleni
	\item izdvojiti one čija su primanja veća od 30000,
	\item izdvojiti stalno zaposlene,
	\item onima koji nisu stalno zaposleni dodati bonuse u iznosu od 10000,	
	\item proveriti da li se za zaposlene date firme posebno vodi stavka visina poreza i
	\item za zaposlene koji su stalno zaposleni izračunati prosek poslednje 3 plate.
\end{itemize}

\end{primer}

\begin{primer}
Kreirati sajt muzeja. Sajt treba da sadrži navigacioni bar: O nama, Postavke, Karte i Kontakt. Stranica O nama treba da sadrži kratak istorijat muzeja, kao i spisak događaja. Postavke treba da sadrži 3 postavke: Afrička umetnost, Kineska umetnost i Evropska umetnost. Svaka od postavki treba da sadrži bar 3 slike, kratak opis kao i datum početka i završetka postavke. Osim toga treba kreirati inventar za svaku od postavki sa barem 3 stavke. Stranica sa kartama treba da sadrži cene karata prema kategorijama, kao i popuste za specijalne kategorije (mlade do 26 godina, penzionere). Stranica za kontakt treba da sadrži formu: Ime i prezime, E-mail, Poruka.\\\\
U programu kreirati:
\begin{itemize}
\item POSTAVKE: Evropska, Afrička i Kineska. Potom, za svaku od postavki kreirati naziv, datume trajanja (od i do) i sifrarnik inventara ( kao niz sifara).
\item Karte: povlašćene kategorije, standardna cena
\item Kontakt: ime i prezime, e-mail, poruka.
\end{itemize}  
\end{primer}

\subsubsection{Funkcije}

\begin{primer}
Napisati funkciju kvadrat(x) koja računa kvadrat
datog broja. Napisati program koji učitava ceo broj i ispuje rezultat poziva
funkcije.
\end{primer}

\begin{primer}
Napisati funkciju apsolutna\_vrednost(x) koja izračunava apsolutnu vrednost broja x. Napisati program koji učitava jedan ceo broj i ispisuje rezultat poziva funkcije.
\end{primer}

\begin{primer}
Napisati funkciju min(x, y, z) koja izračunava minimum tri broja. Napisati program koji učitava tri cela broja i ispisuje rezultat poziva funkcije.
\end{primer}

\begin{primer}
Napisati funkciju stepen(x, n) koja
računa vrednost n-tog stepena realnog broja x. Napisati program koji učitava
relan broj x i ceo broj n i ispisuje rezultat rada funkcije.
\end{primer}

\begin{primer}
Napisati funkciju faktorijel(n) koja računa
faktorijel broja n. Napisati i program koji učitava dva cela broja x i y iz intervala
[0, 12] i ispisuje vrednost zbira x! + y! (x! znači faktorijel broja x).
\end{primer}

\begin{primer}
Napisati funkciju sadrzi(x, c) koja ispituje
da li se cifra c nalazi u zapisu celog broja x. Funkcija treba da vrati 1 ako se cifra
nalazi u broju, a 0 inače. Napisati program koji učitava dva cela broja i ispisuje
rezultat poziva funkcije.
\end{primer}

\begin{primer}
Napisati program za ispitivanje svojstava cifara datog celog
broja.\\
(a) Napisati funkciju sve\_parne\_cifre koja ispituje da li se dati ceo broj sastoji
isključivo iz parnih cifara. Funkcija treba da vrati 1 ako su sve cifre
broja parne i 0 u suprotnom.\\
(b) Napisati funkciju sve\_cifre\_jednake koja ispituje da li su sve cifre datog
celog broja jednake. Funkcija treba da vrati 1 ako su sve cifre broja jednake
i 0 u suprotnom.\\
Napisati program koji učitava ceo broj i ispisuje da li su sve cifre parne i da li su
sve cifre jednake.
\end{primer}

\begin{primer}
Napisati funkciju rastuce(n) koja ispituje da li
su cifre datog celog broja u rastućem poretku. Funkcija treba da vrati vrednost
1 ako cifre ispunjavaju uslov, odnosno 0 ako ne ispunjavaju uslov. Napisati i
program koji učitava ceo broj i ispisuje poruku da li su cifre unetog broja u
rastućem poretku.
\end{primer}

\begin{primer}
Broj je prost ako je deljiv samo sa 1 i sa samim sobom.
Napisati funkciju int prost (int x) koja ispituje da li je dati ceo broj prost.
Funkcija treba da vrati 1 ako je broj prost i 0 u suprotnom. 
\end{primer}

\begin{primer}
Napisati funkciju int prebrojavanje(float x) koja prebrojava
koliko puta se broj x pojavljuje u nizu brojeva koji se unose sve do pojave
broja 0. Napisati program koji učitava vrednost broja x i testira rad napisane
funkcije.
\end{primer}


\begin{primer}
Napisati funkcije za rad sa nizovima celih brojeva.\\
(a) Napisati funkciju ucitaj(a, n) koja učitava elemente niza a dimenzije n.\\
(b) Napisati funkciju stampaj(a, n) koja štampa elemente niza a dimenzije n.\\
(c) Napisati funkciju suma(a, n) koja računa i vraća sumu
elemenata niza a dimenzije n.\\
(d) Napisati funkciju prosek(a, n) koja računa i vraća prosečnu
vrednost (aritmetičku sredinu) elemenata niza a dimenzije n.\\
(e) Napisati funkciju minimum(a, n) koja izračunava i vraća
minimum elemenata niza a dimenzije n.\\
(f) Napisati funkciju pozicija\_maksimuma(a, n) koja izračunava
i vraća poziciju maksimalnog elementa u nizu a dimenzije n. U slučaju
više pojavljivanja maksimalnog elementa, vratiti najmanju poziciju.\\
(g)Napisati funkciju koja sve vrednosti niza uvećava za zadatu vrednost m.
\end{primer}

\begin{primer}
Kreirati sajt zdrave hrane. Stranica treba da sadrži odgovarajuće HTML i CSS elemente (slike, naslove, tekst, itd.). Korisnik treba da odabere da li želi da učestvuje u anketi ili ne. ako odabere da želi, koristeći ugrađenu funkciju prompt zahtevati od korisnika predlog za naziv zdrave hrane i ocenu sajta. Postupak uraditi za barem 6 korisnika. Nakon što su svi uneli podatke (ili odlučili da ih ne unesu), ispisati spisak svih predloga, a potom ispisati prosečnu ocenu sajta. Uraditi odgovarajuće provere unosa.   
\end{primer}

\subsubsection{Periodično izvršavanje funkcija}
\begin{primer}
Kreirati stranicu-prezentaciju pozorista. Sajt treba da sadrži: naslov, paragraf, slike, deo sa kontakt informacijama i ostale odgovarajuće HTML i CSS elemente. Nakon $10$ sekundi od otvaranja sajta korisnik se obavestava da su tokom januara sve cene karata snižene $50\%$. 
\end{primer}

\begin{primer}
Kreirati stranicu za brzo anketiranje stanovnika. Po otvaranju stranice nakon 3 sekunde izlazi prozor sa pitanjem $"$Da li želite da učestvujete u anketi?$"$. Ako je odgovor potvrdan, korisniku se svake 4 sekunde nudi po jedno od 15 pitanja (pitanja idu redom). Pitanja:
\begin{itemize}
\item Koliko imate godina?
\item Koji ste nivo obrazovanja stekli?
\item Da li ste pušač?
\item Da li jedete meso?
\item Da li redovno odlazite na zdravstvene preglede?
\item Da li radite?
\item Koliko puta nedeljno trenirate?
\item Posecujete li muzeje?
\item Posecujete li pozorište?
\item Imate li partnera?
\item Koliko stranih jezika govorite?
\item Imate li kucnog ljubimca?
\item Koristite li računar svakodnevno?
\item Koliko sati dnevno gledate TV?
\item U kom mestu živite?
\end{itemize}  
Anketiranje traje ukupno minut. Po završetku ankete treba da iskoči prozor sa $"$Hvala na izdvojenom vremenu!$"$. Na kraju, u konzoli se ispisuje spisak pitanja i korisnikovih odgovora. 
\end{primer}

\subsection{Interakcija sa DOM-om iz jezika JavaScript}

\subsubsection{Osnove}
\begin{primer}
Kreirati stranicu bioskopa koja sadrži $4$ $div$a. Prvi $div$ sadrzi naslov stranice i logo. Drugi $div$ sadrži sadržaj stranice (content, na primer, najave premijera). Treci $div$ sadrzi informacije poput kontakt telefona i ostalih informacija o cenama karata i datumima nekih od projekcija. Cetvrti div je footer u kome mogu biti smestene adresa preduzeca kao i polje za prijavu za $newsletter$. Pristupiti pasusu unutar drugog $div$-a promeniti mu pozadinu sa crvene na sivu. Dohvatiti sve naslove $h2$ i promeniti im boju na belu. Postaviti boju elementa sa $id$-jem "neki\_odabrani" na plavu. Za liste postaviti veličinu slova na $11px$. 
\end{primer}

\begin{primer}
Dohvatiti sve elemente liste unutar elementa sa $id$-jem $cenovnik$. Podesiti dohvaćenim elementima slova da budu iskošena, i promeniti boju na belo. Promeniti pozadinsku boju $cenovnika$ na ljubičasto.
\end{primer}

\begin{primer}
Za kreiranu stranicu koja sadrzi 10 pasusa, postaviti pozadinsku boju svakom drugom na svetlo sivu.
\end{primer}

\begin{primer}
Za stranicu sa bioskopom kreirati novi element koji u sebi sadrži 6 $div$-ova sa najavama budućih projekcija. Svaka od najava treba da sadrži naslov filma, poster, datum premijere, kratak opis i link ka detaljnijim informacijama. Treba promeniti boju prvom, poslednjem, kao i drugom i pretposlednjem elementu na: plavu (prvi i poslednji), svetlo plavu (drugi i pretposlednji). Preostala dva elementa treba da ostanu bela. Napomena: slobodno odabrati boje iz palete boja koje bi se uklopile sa vasim sajtom.   
\end{primer}

\begin{primer}
Na stranicu sa bioskopom postaviti tooltip sa tekstom $"$Gledajmo budućnost zajedno!$"$ na glavni naslov. Kreirati element koji sadrži naslov $"$Najpopularniji film u $2018$.$"$, poster i naziv filma. Postaviti atribute širine i visine slike koja predstavlja najpopularniji film na $100$ prema $150$px. Dohvatiti atribute vezane za linkove ka narednim projekcijama iz elementa koji sadrži najave i promeniti ih tako da predstavljaju linkove ka $IMDB$ stranicama filmova. Na kraju, za najpopularniji film, dodati ocenu i link ka $IMDB$ stranici.  
\end{primer}

\subsubsection{Kreiranje elemenata}
\begin{primer}
Na stranicu sa pozorištem dodati nove elemente. Elemente dodavati kreiranjem novih elemenata kroz $JavaScript$. Obavezno dodati tabelu, sliku, link, dok su ostali elementi po izboru u zavisnosti od rada.
\end{primer}

\begin{primer}
Kreirati stranicu na kojoj se nalazi samo jedan prazan $div$ sa $id$-jem $omotac$. U taj $div$, dodavati elemente korišćenjem funkcije $createElement$ dok se ne dobije stranica koja sadrži rezultate ispita. Stranica treba da sadrži barem naslov i tabelu sa spiskom učenika i njihovim ocena koji se izvlači iz objekta.
\end{primer}

\begin{primer}
Za uneti ceo broj $n$, izgenerisati tablicu množenja veličine $n$ koristeći table element i dodavanje uz pomoć interakcije sa DOM drvetom. Doterati stranicu koristeći CSS.
\end{primer}

\begin{primer}
Kreirati sajt koji će sadržati biografije do 3 znamenita naučnika. Na osnovu naziva slike koji se unosi preko prompta, dodati na stranicu primer biografije zadate ličnosti. Na primer, za naziv slike $tesla.jpg$ na stranicu dodati naslov Nikola Tesla, paragraf sa kratkom biografijom, sliku, kao i link ka stranici na Wikipediji. Svaka biografija treba da bude prigodno uokvirena. Ponuditi unos za do 3 licnosti, tako sto ce se preko prompta najpre uneti broj licnosti, a potom i nazivi slika koje korisnik želi da iskoristi pri kreiranju stranice. Sajt ukrasiti korišćenjem prigodinih HTML i CSS elemenata.
\end{primer}

\begin{primer}
Kreirati stranicu koja vrši heširanje tajne poruke koju korisnik unosi preko prompta. Heširanje predstavlja postupak sakrivanja poruke. U ovom zadatku heš treba predstaviti preko tabele, koja u vidu niza predstavlja poruku uz pomoć crvenih, plavih i zelenih kvadratića dimenzija 10x10 piksela. Heš funkcija je sledeća:
\begin{itemize}
\item ako je ostatak pri deljenju kodnog broja karaktera sa 3 jednak 1 onda zelena boja,
\item ako je ostatak pri deljenju kodnog broja karaktera sa 3 jednak 2 onda plava boja
\item inače, crvena. 
\end{itemize}
Prikaz programa dat je na slici \ref{fig:hes}.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{pictures/hes.png}
\end{center}
\caption{Prikaz programa.}
\label{fig:hes}
\end{figure}

\end{primer}

\subsubsection{Reagovanje na događaje}

\begin{primer}
Kreirati sajt "Mala škola programiranja". Sajt treba da sadrži:
\begin{itemize}
\item pozadinsku sliku
\item navigacioni bar (pocetna kursevi kontakt)
\item na početnoj strani treba da se nalazi malo polje sa pitanjem $"$Da li volite da
     programirate?$"$, a ispod toga dva button-odgovora na pitanje $DA$ i $NE$ 
\item klikom na dugme DA izbacuje se alert sa natpisom "Svaka cast! Buducnost je Vasa!"
\item prelaskom miša preko dugmeta NE, dugme treba da pobegne na proizvoljni deo ekrana
    (koristiti funkciju Random ---> Math.Random())
\item sajt je neophodno ukrasiti odgovarajucim CSS elementima. 
\end{itemize}
\end{primer}

\begin{primer}
Kreirati igru $X$-$O$. Igra se sastoji iz table $3$x$3$. Naizmenično se unose $X$ i $O$ dok se u bilo kom smeru ne nađu tri uzastopna ista znaka. Na kraju se ispisuje obaveštenje o tome koji igrač je pobedio i $"$Nerešeno!$"$ ako je rezultat nerešen.
\end{primer}


\begin{primer}
Skočko - Kreirati igru koja je poput igre skočko iz kviza "Slagalica". Nasumično se generišu 4 simbola od 6 mogućih. Potom se korisniku nudi da unese odgovarajuće
\end{primer}


\subsubsection{Obrada formulara}

\begin{primer}
Kreirati "Mirror" sajt za izvrtanje korisnickog unosa. Pozadinska slika bi trebalo da bude
ogledalo. Kucanjem teksta u input polje istovremeno u paragrafu ispod se ispisuje tekst u 
obrnutom poretku. Sajt ukrasiti odgovarajucim CSS elementima.
\end{primer}

\begin{primer}
Kreirati igru vešala. Najpre se unosi skrivena reč, na osnovu koje se formiraju polja. Potom se na neki od dva načina nudi korisniku da odabere slovo:
\begin{itemize}
\item unosom kroz polje ili
\item klikom na polje sa slovom.
\end{itemize}

\end{primer}

\begin{primer}
Modifikovati prethodni zadatak, tako da se korisniku ponudi najpre odabir lakše ili teže varijante igre. Ako je odabrana lakša verzija igra se odigrava kao u prethodnom zadatku.  Ako je odabrana teža verzija igra se modifikuje tako da se korisnik stavlja u vremensko ograničenje od 30, 45 ili 60 sekundi i broj pokušaja mu se ograničava na polovinu dužine reči. To znači da do kraja igre dolazi:
\begin{itemize}
\item kada je korisnik pogodio skrivenu reč,
\item kada je isteklo vreme ili
\item kada je istekao broj pokušaja.
\end{itemize}
\end{primer}

\begin{primer}
Kreirati sajt za iznajmljivanje prostora za proslavu rodjendana. Sajt treba da sadrži odgovarajući
 navigacioni bar: o nama, ponuda, galerija I kontakt. 
 Kreirati funkciju za obračunavanje cene usluge po satu. 
 Funkcija treba da sadrži nekoliko argumenata:
\begin{itemize}
 \item broj sati (podrazumevano 2), 
 \item broj dece (podrazumevano 10),
 \item broj odraslih (podrazumevano 5),
 \item ketering (podrazumevano "da"). 
\end{itemize}  
Parametre menjati kroz pozive funkcije za različite argumente. Dopuniti zadatak tako da se korisniku
ponudi da preko forme, klikom na $submit$ dugme (reagovanjem na $click$) omogući formiranje cene 
na osnovu njegovih potreba. Konacnu cenu ispisati na strani.  
Cena se formira po formuli:
     $(brojsati*0.5*brojdece + brojsati*0.7*brojodraslih) *150$, 
u slučaju da je ketering isključen, smanjiti cenu za ukupan broj osoba * $20$. 
\end{primer}

\begin{primer}
Zadatak sa biografijama (naucnicima) oplemeniti i umesto prompta uz pomoc eventova
pokupiti odgovarajuce informacije (broj naučnika, nazive slika), a potom kreirati stranicu. Dozvoljeno je kreiranje stranice na kojoj ce se nalaziti buttoni/input polja i slicno i tako pokupiti broj 1, 2 ili 3 i naziv slike/naucnika.
\end{primer}

\begin{primer}
Kreirati zdravstvenu stanicu. Klikom na dugme dodaj pacijenta izbacuje se forma za dodavanje novog pacijenta. Podatke o pacijentima smeštati kao niz objekata, sa sledećim svojstvima:
\item Ime
\item Prezime
\item Datum rođenja
\item JMBG (13 cifara)
\item Krvna grupa (A, B, AB, 0)
\item RH faktor (pozitivna, negativna).
Klikom na dugme sačuvaj informacije, unete informacije se smeštaju u odgovarajući 
objekat. Omogućiti izlistavanje svih pacijenata, kroz tabelu: ime, prezime i krvna grupa.
Proveriti ispravnost svih unosa.
\end{primer}

\begin{primer}
Dopuniti zadatak sa zdravstvenom stanicom na sledeći način. 
Kreirati pored dugmeta koje izbacuje spisak svih pacijenata dugme koje vrši filtraciju podataka o pacijentima.
Klikom na dugme filteri izbacuje se nekoliko mogućih opcija kroz select element za koje, u zavisnosti da li je opcija obeležena vrši se odgovarajuće filtriranje.
Dodatne parametre filtera uneti pored kroz input polje.
Omogućiti naredne opcije:
\begin{itemize}
\item izdvajanje određene krvne grupe
\item odabir RH faktora
\item izdvajanje svih pacijenata starijih od 30 godina
\item izdvajanje svih pacijenata sa nekim imenom 
\end{itemize}
Klikom na dugme "Filtriraj" izbacuje se spisak pacijenata sa brojevima kartona koji ispunjavaju predviđene uslove. 
U slučaju da je potrebno prebrojati pacijente, to se omogućava uz pomoć check boxa prebroj. Ukupan broj pacijenata se ispisuje ispod spiska.
Npr.: Korišćenjem novih koncepata (filter, map i reduce), izračunati broj pacijenata sa A negativnom krvnom grupom.
\end{primer}

\subsection{Dodatni zadaci}
\begin{primer}
Kreirati stranicu zdrave hrane. Koristeći ugrađenu funkciju prompt zahtevati od korisnika količinu badema koju želi da kupi(u gramima), a potom u alert prozoru ispisati konačnu cenu za unetu količinu. Npr. ako je badem 2000 dinara po kilogramu, a korisnik želi 500 grama, u alertu treba da se ispiše 1000 dinara.  
\end{primer}

\begin{primer}
Kreirati sajt za organizovanje proslava. Sajt treba da sadrži navigacioni bar sa stavkama: o nama, rođendani, proslave jubileja, svadbe i krštenja, kao i kontakt stranu. Rođendanske proslave se sastoje iz više kategorija, kao što su proslave punoletstva, proslave prvih rodjendana i proslave rođendana. Svaka od stavki navigacije vodi ka novim stranicama koje sadrže paragraf sa kratkim opisom usluga koje se nude, tabele sa cenama usluga (Ketering, Premium Ketering, Piće (osnovna i premium ponuda), dekoracija, muzika, transport do lokacije itd.). Svaka od strana sadrži i barem 3 moguće lokacije za proslave, sa sumom cena.

\end{primer}


\subsection{Domaći zadaci}
\begin{primer}
Na koje $if$ se odnosi $else$?
\begin{verbatim}
if (izraz1)
    if (izraz2)
        naredba1
else
    naredba2
\end{verbatim}
\end{primer}
\begin{primer}
Na koje $if$ se odnosi $else$?
\begin{verbatim}
if (izraz1) {
   if (izraz2)
      naredba1
} else
    naredba2
\end{verbatim}
\end{primer}

\begin{primer}
Napisati program koji za uneti pozitivan trocifreni broj na
standardni izlaz ispisuje njegove cifre jedinica, desetica i stotina
\end{primer}

\begin{primer}
Napisati program koji za uneti pozitivan četvorocifreni
broj:\\
(a) izračunava proizvod cifara\\
(b) izračunava razliku sume krajnjih i srednjih cifara\\
(c) izračunava sumu kvadrata cifara\\
(d) izračunava broj koji se dobija ispisom cifara u obrnutom poretku\\
(e) izračunava broj koji se dobija zamenom cifre jedinice i cifre stotine\\
\end{primer}

\begin{primer}
Broj je Armstrongov ako je jednak zbiru kubova svojih
cifara. Napisati program koji za dati trocifren broj proverava da li je Armstrongov.
\end{primer}

\begin{primer}
Napisati program koji ispisuje proizvod parnih cifara unetog
četvorocifrenog broja.
\end{primer}

\begin{primer}
Napisati program koji za ceo broj x ispisuje njegov
znak, tj da li je broj jednak nuli, manji od nule ili veći od nule.
\end{primer}

\begin{primer}
Napisati program koji za uneti prirodan broj ispisuje da li
je on deljiv sumom svojih cifara.
\end{primer}

\begin{primer}
Promptom se unosi ceo pozitivan broj n, a potom i n celih
brojeva. Izračunati i ispisati zbir onih brojeva koji su parni.
\end{primer}

\begin{primer}
Program učitava cele brojeve sve do unosa broja nula 0.
Napisati program koji izračunava i ispisuje aritmetičku sredinu unetih brojeva na
četiri decimale.
\end{primer}

\begin{primer}
U prodavnici se nalaze artikli, čije cene su realni pozitivni
brojevi. Program unosi cene artikala sve do unosa broja nula 0. Napisati program
koji izračunava i ispisuje prosečnu vrednost cena u radnji.
\end{primer}

\begin{primer}
U prodavnici se nalaze artikala čije cene su realni pozitivni
brojevi. Program unosi cene artikala sve do unosa broja nula 0. Napisati program
koji izračunava i ispisuje prosečnu vrednost cena u radnji.
\end{primer}




\section{Zaključak}
\label{sec:zakljucak}

\addcontentsline{toc}{section}{Literatura}
%\appendix
\bibliography{seminarski} 
\bibliographystyle{plain}

\appendix
\section{Dodatak}


\end{document}
